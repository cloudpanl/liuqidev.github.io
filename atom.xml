<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WizardLQ’s | 魔法师の小茶馆</title>
  
  <subtitle>Keep moving, never give up. | 锲而不舍，金石可镂.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.blankspace.cn/"/>
  <updated>2018-10-19T11:27:19.101Z</updated>
  <id>https://www.blankspace.cn/</id>
  
  <author>
    <name>liuqidev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.blankspace.cn/2018/10/19/EM/"/>
    <id>https://www.blankspace.cn/2018/10/19/EM/</id>
    <published>2018-10-19T11:26:37.848Z</published>
    <updated>2018-10-19T11:27:19.101Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Questions and Answers</title>
    <link href="https://www.blankspace.cn/2018/10/19/questions-and-answers/"/>
    <id>https://www.blankspace.cn/2018/10/19/questions-and-answers/</id>
    <published>2018-10-19T00:21:47.000Z</published>
    <updated>2018-10-19T02:40:16.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>stick with 按照继续</p><p>in place 适当的</p><p>motivation (the reason to learn)</p></blockquote><h3 id="Self-introduction"><a href="#Self-introduction" class="headerlink" title="Self-introduction"></a>Self-introduction</h3><p>Framework</p><ul><li>basic infomation</li><li>education background</li><li>experience</li><li>future plan</li></ul><p>Learning language need praticing.</p><blockquote><p>What happen after your interview?</p></blockquote><h2 id="Questions-amp-Problem"><a href="#Questions-amp-Problem" class="headerlink" title="Questions &amp; Problem"></a>Questions &amp; Problem</h2><p>What is the problem</p><p>What is your problem</p><p>What is your question</p><blockquote><p>hard evidence</p><p>lose track</p><p>write on the fly  ??</p></blockquote><ul><li>Base on the fact and numbers.</li><li>Keep your answer short and right  to the point</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>video</p><p>Name, vocation, location, address, numbers</p><blockquote><p>关键词</p><p>conduct run do performance  work</p><p>configure </p><p>configuration(s) set-up(s) setting(s)</p></blockquote><h3 id="Debate-World-Cup"><a href="#Debate-World-Cup" class="headerlink" title="Debate World Cup"></a>Debate World Cup</h3><p>Chairman</p><p>Positive/Affiemative side </p><p>Negtive side</p><h3 id="Positive-side-High-salary-job"><a href="#Positive-side-High-salary-job" class="headerlink" title="Positive side: High salary job"></a>Positive side: High salary job</h3><ul><li>?</li><li>Money is important</li><li>difficult</li></ul><h3 id="称述"><a href="#称述" class="headerlink" title="称述"></a>称述</h3><blockquote><p>recruiment 补充</p></blockquote><p>两种不同的场景，一种是高薪酬但是不开森；另一种是低薪酬</p><h3 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h3><ol><li><p>临时，钱买快乐</p></li><li><p>love your</p></li><li>creation</li></ol><p>正方</p><ul><li>growup: 高薪酬===困难，困难===成长 | 简单的事情无法带来进步</li></ul><p>反方</p><ul><li>低薪!==简单</li></ul><h3 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h3><p>…</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>动机：</p><ul><li>群面面试</li><li>表达赞同和不赞同</li></ul><p>关键：</p><ul><li>对话，有来有回</li><li>不光是表述我赞同还是不赞同xx观点，重要的是给予支撑</li></ul><blockquote><p>辩论会主持人: minutes taker, monitor </p><p>opening statement</p><p>conclusion(?) statement</p><p>salary+other income=income </p><p>paying</p><p>i am for/agast</p></blockquote><ul><li>分条<ul><li>at the begining, firstly, </li><li>then, moreover</li><li>fu..more</li><li>finally, one more thing,  in the end, in summary, in conclusion</li></ul></li><li>举例</li></ul><h3 id="video-test"><a href="#video-test" class="headerlink" title="video test"></a>video test</h3><blockquote><p> trouble shooting</p></blockquote><p>video 2</p><blockquote><p>repoter, </p><p>PR department head</p><p>scandal</p></blockquote><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>角色扮演。一方老师，一方学生。对话，关于是否接受assignment。        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;stick with 按照继续&lt;/p&gt;
&lt;p&gt;in place 适当的&lt;/p&gt;
&lt;p&gt;motivation (the reason to learn)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Self-introduction&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Englishh" scheme="https://www.blankspace.cn/categories/Englishh/"/>
    
      <category term="Notes" scheme="https://www.blankspace.cn/categories/Englishh/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>方差分析</title>
    <link href="https://www.blankspace.cn/2018/10/19/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    <id>https://www.blankspace.cn/2018/10/19/方差分析/</id>
    <published>2018-10-18T22:34:41.000Z</published>
    <updated>2018-10-20T05:09:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="方差分析引论"><a href="#方差分析引论" class="headerlink" title="方差分析引论"></a>方差分析引论</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>定义1：检验多个总体均值是否相等的统计方法，成为方差分析（analysis of variance, ANOVA）。也叫F检验（F test）。<ul><li>对象：分类型自变量对数值型自变量的影响。</li><li>作用：自变量之间有没有关系，关系的强度如何。显著性。</li><li>举例1：Head Movement Example: neural talking,  expressive movement, random head movement多组实验之间评价，需要用到方差分析。average , one-way ANOVA(F统计量（k-1, n-k），P)，说明有显著性差异，但是没有说明哪个好。Post-hoc analysis(tukey HSD)处理说明那个更好。</li><li>举例2：treatments measurement</li></ul></li></ul><hr><ul><li>定义2：所要检测的对象称为因素或者因子（factor）</li><li>定义3：因素的不同表现称为水平或者处理（treatment）</li><li>定义4：每个因子水平下得到的样本数据称为观测值。</li></ul><h3 id="基本思想和原理"><a href="#基本思想和原理" class="headerlink" title="基本思想和原理"></a>基本思想和原理</h3><h4 id="误差分解"><a href="#误差分解" class="headerlink" title="误差分解"></a>误差分解</h4><h5 id="方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。"><a href="#方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。" class="headerlink" title="方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。"></a>方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。</h5><ul><li>定义5：组内误差（within groups），来自水平内部的数据误差。组内误差只包含随机误差。</li></ul><ul><li>定义6：来自不同水平之间的数据误差成为组建误差（between groups）组间误差既包含随机误差也包含系统误差。</li></ul><ul><li>定义7：全部数据误差大小的平方和称为总平方和（sum of squares for total, SST）</li><li>定义8：组内误差大小平方和成为组内平方和（sum of suqares for error(within), SSE/SSw）</li><li>定义9：组间平方和反映组间误差的平方和（sum of squares for factor A(between), SSA/SSb）</li></ul><h4 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h4><ul><li>比较系统误差和随机误差两类误差（具体通过方差比），以检验均值是否相等。（假设$H_0$:各族总体均值相等）。</li></ul><h2 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h2><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><p>假设条件</p><ul><li>独立</li><li>正态分布</li><li>variance</li></ul><h3 id="无交互双因素方差分析"><a href="#无交互双因素方差分析" class="headerlink" title="无交互双因素方差分析"></a>无交互双因素方差分析</h3><h3 id="有交互双因素方差分析"><a href="#有交互双因素方差分析" class="headerlink" title="有交互双因素方差分析"></a>有交互双因素方差分析</h3><h2 id="Z-t-F-统计量"><a href="#Z-t-F-统计量" class="headerlink" title="Z-, t-, F-统计量"></a>Z-, t-, F-统计量</h2><ul><li>3个以上，F检验</li><li>1个，Z，$\mu$已知，$Z=\frac{x_i-\mu}{\sigma /\sqrt{n}}$</li><li>t统计<ul><li>paried two-sample</li></ul></li></ul><p>合并方差和非合并方差</p><p>任务sx和sy相等，合并方差作为总体方差。</p><p>比较T统计量和F统计量之间的关系</p><p>$F=t^2$</p><h2 id="后处理（Post-Hoc-Test）"><a href="#后处理（Post-Hoc-Test）" class="headerlink" title="后处理（Post-Hoc Test）"></a>后处理（Post-Hoc Test）</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul><li>找出来哪个最好。</li><li>找出来一系列的t-test进行检验（两两作比较）。</li><li>问题：type-I error inflation。$\alpha$</li><li>解决：每次显著性水平控制在一定很小的范围内, or ,将几个组组合在一起比较显著性水平。<ul><li>Bonferroni</li><li>Tukey Test</li><li>Scheffe’s Test</li></ul></li></ul><h3 id="Bonferroni"><a href="#Bonferroni" class="headerlink" title="Bonferroni"></a>Bonferroni</h3><h3 id="Tukey"><a href="#Tukey" class="headerlink" title="Tukey"></a>Tukey</h3><h3 id="Scheffe"><a href="#Scheffe" class="headerlink" title="Scheffe"></a>Scheffe</h3><h3 id="Holm-and-Hochberg"><a href="#Holm-and-Hochberg" class="headerlink" title="Holm and Hochberg"></a>Holm and Hochberg</h3><ul><li><p>从小到大排序，越小越有可能是显著的。</p></li><li><blockquote><p>$p1, p2, \dots , pn$</p></blockquote></li></ul><p>若在p2处停，则表明p1，p2组和其他剩余的组之间有显著性差异。</p><p>下集预告</p><ul><li>考虑多个因素之间的关系</li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;方差分析引论&quot;&gt;&lt;a href=&quot;#方差分析引论&quot; class=&quot;headerlink&quot; title=&quot;方差分析引论&quot;&gt;&lt;/a&gt;方差分析引论&lt;/h2&gt;&lt;h3 id=&quot;相关术语&quot;&gt;&lt;a href=&quot;#相关术语&quot; class=&quot;headerlink&quot; title=&quot;相关术语&quot;&gt;&lt;/a&gt;相关术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义1：检验多个总体均值是否相等的统计方法，成为方差分析（analysis of variance, ANOVA）。也叫F检验（F test）。&lt;ul&gt;
&lt;li&gt;对象：分类型自变量对数值型自变量的影响。&lt;/li&gt;
&lt;li&gt;作用：自变量之间有没有关系，关系的强度如何。显著性。&lt;/li&gt;
&lt;li&gt;举例1：Head Movement Example: neural talking,  expressive movement, random head movement多组实验之间评价，需要用到方差分析。average , one-way ANOVA(F统计量（k-1, n-k），P)，说明有显著性差异，但是没有说明哪个好。Post-hoc analysis(tukey HSD)处理说明那个更好。&lt;/li&gt;
&lt;li&gt;举例2：treatments measurement&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;定义2：所要检测的对象称为因素或者因子（factor）&lt;/li&gt;
&lt;li&gt;定义3：因素的不同表现称为水平或者处理（treatment）&lt;/li&gt;
&lt;li&gt;定义4：每个因子水平下得到的样本数据称为观测值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本思想和原理&quot;&gt;&lt;a href=&quot;#基本思想和原理&quot; class=&quot;headerlink&quot; title=&quot;基本思想和原理&quot;&gt;&lt;/a&gt;基本思想和原理&lt;/h3&gt;&lt;h4 id=&quot;误差分解&quot;&gt;&lt;a href=&quot;#误差分解&quot; class=&quot;headerlink&quot; title=&quot;误差分解&quot;&gt;&lt;/a&gt;误差分解&lt;/h4&gt;&lt;h5 id=&quot;方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。&quot;&gt;&lt;a href=&quot;#方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。&quot; class=&quot;headerlink&quot; title=&quot;方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。&quot;&gt;&lt;/a&gt;方差分析，虽然感兴趣的是均值，但是在判断均值之间是否有差异要借助方差。通过数据误差来源的分析来判断不同总体之间的均值是否相等。&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;定义5：组内误差（within groups），来自水平内部的数据误差。组内误差只包含随机误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;定义6：来自不同水平之间的数据误差成为组建误差（between groups）组间误差既包含随机误差也包含系统误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;定义7：全部数据误差大小的平方和称为总平方和（sum of squares for total, SST）&lt;/li&gt;
&lt;li&gt;定义8：组内误差大小平方和成为组内平方和（sum of suqares for error(within), SSE/SSw）&lt;/li&gt;
&lt;li&gt;定义9：组间平方和反映组间误差的平方和（sum of squares for factor A(between), SSA/SSb）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;误差分析&quot;&gt;&lt;a href=&quot;#误差分析&quot; class=&quot;headerlink&quot; title=&quot;误差分析&quot;&gt;&lt;/a&gt;误差分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;比较系统误差和随机误差两类误差（具体通过方差比），以检验均值是否相等。（假设$H_0$:各族总体均值相等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;单因素方差分析&quot;&gt;&lt;a href=&quot;#单因素方差分析&quot; class=&quot;headerlink&quot; title=&quot;单因素方差分析&quot;&gt;&lt;/a&gt;单因素方差分析&lt;/h2&gt;&lt;h2 id=&quot;双因素方差分析&quot;&gt;&lt;a href=&quot;#双因素方差分析&quot; class=&quot;headerlink&quot; title=&quot;双因素方差分析&quot;&gt;&lt;/a&gt;双因素方差分析&lt;/h2&gt;&lt;p&gt;假设条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立&lt;/li&gt;
&lt;li&gt;正态分布&lt;/li&gt;
&lt;li&gt;variance&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;无交互双因素方差分析&quot;&gt;&lt;a href=&quot;#无交互双因素方差分析&quot; class=&quot;headerlink&quot; title=&quot;无交互双因素方差分析&quot;&gt;&lt;/a&gt;无交互双因素方差分析&lt;/h3&gt;&lt;h3 id=&quot;有交互双因素方差分析&quot;&gt;&lt;a href=&quot;#有交互双因素方差分析&quot; class=&quot;headerlink&quot; title=&quot;有交互双因素方差分析&quot;&gt;&lt;/a&gt;有交互双因素方差分析&lt;/h3&gt;&lt;h2 id=&quot;Z-t-F-统计量&quot;&gt;&lt;a href=&quot;#Z-t-F-统计量&quot; class=&quot;headerlink&quot; title=&quot;Z-, t-, F-统计量&quot;&gt;&lt;/a&gt;Z-, t-, F-统计量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;3个以上，F检验&lt;/li&gt;
&lt;li&gt;1个，Z，$\mu$已知，$Z=\frac{x_i-\mu}{\sigma /\sqrt{n}}$&lt;/li&gt;
&lt;li&gt;t统计&lt;ul&gt;
&lt;li&gt;paried two-sample&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合并方差和非合并方差&lt;/p&gt;
&lt;p&gt;任务sx和sy相等，合并方差作为总体方差。&lt;/p&gt;
&lt;p&gt;比较T统计量和F统计量之间的关系&lt;/p&gt;
&lt;p&gt;$F=t^2$&lt;/p&gt;
&lt;h2 id=&quot;后处理（Post-Hoc-Test）&quot;&gt;&lt;a href=&quot;#后处理（Post-Hoc-Test）&quot; class=&quot;headerlink&quot; title=&quot;后处理（Post-Hoc Test）&quot;&gt;&lt;/a&gt;后处理（Post-Hoc Test）&lt;/h2&gt;&lt;h3 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;找出来哪个最好。&lt;/li&gt;
&lt;li&gt;找出来一系列的t-test进行检验（两两作比较）。&lt;/li&gt;
&lt;li&gt;问题：type-I error inflation。$\alpha$&lt;/li&gt;
&lt;li&gt;解决：每次显著性水平控制在一定很小的范围内, or ,将几个组组合在一起比较显著性水平。&lt;ul&gt;
&lt;li&gt;Bonferroni&lt;/li&gt;
&lt;li&gt;Tukey Test&lt;/li&gt;
&lt;li&gt;Scheffe’s Test&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Bonferroni&quot;&gt;&lt;a href=&quot;#Bonferroni&quot; class=&quot;headerlink&quot; title=&quot;Bonferroni&quot;&gt;&lt;/a&gt;Bonferroni&lt;/h3&gt;&lt;h3 id=&quot;Tukey&quot;&gt;&lt;a href=&quot;#Tukey&quot; class=&quot;headerlink&quot; title=&quot;Tukey&quot;&gt;&lt;/a&gt;Tukey&lt;/h3&gt;&lt;h3 id=&quot;Scheffe&quot;&gt;&lt;a href=&quot;#Scheffe&quot; class=&quot;headerlink&quot; title=&quot;Scheffe&quot;&gt;&lt;/a&gt;Scheffe&lt;/h3&gt;&lt;h3 id=&quot;Holm-and-Hochberg&quot;&gt;&lt;a href=&quot;#Holm-and-Hochberg&quot; class=&quot;headerlink&quot; title=&quot;Holm and Hochberg&quot;&gt;&lt;/a&gt;Holm and Hochberg&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从小到大排序，越小越有可能是显著的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;$p1, p2, \dots , pn$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若在p2处停，则表明p1，p2组和其他剩余的组之间有显著性差异。&lt;/p&gt;
&lt;p&gt;下集预告&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑多个因素之间的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h4&gt;
    
    </summary>
    
      <category term="Math" scheme="https://www.blankspace.cn/categories/Math/"/>
    
      <category term="Statistics" scheme="https://www.blankspace.cn/categories/Math/Statistics/"/>
    
      <category term="ANOVA" scheme="https://www.blankspace.cn/categories/Math/Statistics/ANOVA/"/>
    
    
      <category term="Statistics" scheme="https://www.blankspace.cn/tags/Statistics/"/>
    
      <category term="ANOVA" scheme="https://www.blankspace.cn/tags/ANOVA/"/>
    
  </entry>
  
  <entry>
    <title>R介绍</title>
    <link href="https://www.blankspace.cn/2018/10/17/R%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.blankspace.cn/2018/10/17/R介绍/</id>
    <published>2018-10-17T06:07:01.000Z</published>
    <updated>2018-10-21T08:46:31.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书籍这里使用的是Robert IKabacoff著王小宁，刘撷芯等译的的《R语言实践（第二版）》。</p><p>编程环境使用的Rstudio， R的版本是R3.5.1。</p><p>教程：<code>swirl</code>。</p><blockquote><p>它太神奇了，满载珍宝，可以让那些狡猾聪明和粗野胆大的人得以充分满足；但并不适合胆小者。</p><p>——Q. “Q Who”, 《星际迷航》</p></blockquote><h2 id="Lesson-1-Basic-Building-Blocks"><a href="#Lesson-1-Basic-Building-Blocks" class="headerlink" title="Lesson 1: Basic Building Blocks"></a>Lesson 1: Basic Building Blocks</h2><ul><li>赋值<code>&lt;-</code></li><li>打印<code>print()</code></li><li>帮助<ul><li><code>?</code></li></ul></li><li>变量：接在赋值符号的左边</li><li>数组<code>c()</code><ul><li><code>c()</code>中参数可以依然是向量</li><li>对向量可以直接进行看起来像对标量进行的数值运算，例如：<code>+</code>, <code>-</code>, <code>/</code>, <code>^</code>， <code>sqrt()</code>, <code>abs()</code>等, 运算结果是逐元素的，类似于Numpy中的广播。</li></ul></li><li>向量运算<ul><li>两个向量进行运算，若二者长度是相等的，则R会对向量进行著逐个元素计算（element-by-element）</li><li>若连个向量长度不等，则会使用短的向量来填充，直到二者长度相等后，两者再进行和相等长度向量相同的运算</li><li>向量和标量的运算，将标量视作长度是一的向量，然后将其循环填充至与向量长度相等的向量，再进行运算</li></ul></li></ul><p><img src="/2018/10/17/R介绍/向量运算.png" alt=""></p><ul><li>补全：<code>tap</code></li><li>历史输入：<code>↑</code></li><li>关于swirl assignment token<ul><li>去Coursera上选修约翰霍普金斯大学的R学习课程</li><li>第一周的作业是关于swirl提交的，网页右边栏会有提交码</li><li>在swirl完成的时候输入提交码，作业就提交成功</li></ul></li></ul><p><img src="/2018/10/17/R介绍/coursera R课程.png" alt=""></p><p><img src="/2018/10/17/R介绍/coursera识别码.png" alt=""></p><h2 id="Lesson-2-Workspace-and-Files"><a href="#Lesson-2-Workspace-and-Files" class="headerlink" title="Lesson 2: Workspace and Files"></a>Lesson 2: Workspace and Files</h2><ul><li><p>获取当前工作区路径：<code>getwd()</code></p><ul><li>返回原来的工作路径：<code>getwd(old.dir)</code></li></ul></li><li><p>查看当前工作区下有哪些对象：`ls()（和Linux命令类似）</p></li><li><p>产看有哪些文件：</p><ul><li><code>list.files()</code></li><li>查看帮助：<code>?list.files()</code></li></ul></li><li><p>查看函数的参数有哪些：例如<code>args(name = list.files )</code></p><ul><li><blockquote><p><img src="/2018/10/17/R介绍/查看参数.png" alt=""></p></blockquote></li></ul></li></ul><ul><li>保存旧路径：<code>old.dir &lt;- getwd()</code></li><li>创建新路径：<code>dir.creat()</code></li><li>设置(新的)工作路径：<code>setwd()</code>, 例如<code>setwd(&quot;testdir&quot;)</code></li><li>创建新文件：<code>file.create()</code>，例如<code>file.create(&quot;mytest.R&quot;)</code></li><li>查看当前工作路径文件：<code>list.files()</code></li><li>产看当前工作路径某文件是否存在：<code>file.exists()</code>, 例如<code>file.exists(&quot;mytest.R&quot;)</code></li><li>查看文件信息：<code>file.info()</code>, 例如<code>file.info(&quot;mytest.R&quot;)</code></li><li>重命名文件：<code>file.rename(from, to)</code>, 例如<code>file.rename(&quot;oldname.R&quot;, &quot;newname.R&quot;)</code>，将原来叫做<code>oldname.R</code>的文件重命名为<code>newname.R</code></li><li>删除文件：<code>file.remove()</code></li><li>复制文件：<code>file.copy(from, to)</code>, 例如<code>file.copy(&quot;mytest2.R&quot;, &quot;mytest3.R&quot;)</code>, 将文件<code>mytest2.R</code>复制成为<code>mytest3.R</code></li><li>相对路径：<ul><li>查看文件的相对路径：<code>file.path()</code>，例如<code>file.path(&quot;mytest.R&quot;)</code></li><li>配合<code>dir.create()</code>创建想对路径的多层文件夹</li></ul></li><li>创建路径：<code>dir.crate()</code>，举例<code>dir.create(file.path(&quot;testdir2&quot;, &quot;testdir3&quot;), recursive = TRUE)</code>, 在当前工作路径下以递归方式创建文件路径<code>testdir2/testdir3</code></li></ul><h2 id="Lesson-3-Sequences-of-Numbers"><a href="#Lesson-3-Sequences-of-Numbers" class="headerlink" title="Lesson 3: Sequences of Numbers"></a>Lesson 3: Sequences of Numbers</h2><ul><li><code>:</code><ul><li>例如<code>1:10</code>, 输出的是<code>1  2  3  4  5  6  7  8  9 10</code>, 即步长为1的<code>[1,10]</code>升序的闭区间的数</li><li>例如<code>pi:10</code>，输出的是<code>3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593</code>,  从<code>pi</code>开始每次步长为1，直到小于10的那个点的序列</li><li>例如<code>10:1</code>, 输出的是<code>10  9  8  7  6  5  4  3  2  1</code>, 即步长为1，<code>[10, 1]</code>倒序的闭区间的数</li></ul></li><li>获取关于符号的帮助文档<ul><li><code>?`:` </code> ，将符号阔在<code>` </code>对中，前面加上问号</li></ul></li><li><code>seq()</code>创建序列<ul><li>例如<code>seq(1, 20)</code>，输出的是<code>1  2  3  4  5  6  7  8  9 10</code>, 和<code>:</code>作用类似，步长为1。</li><li>例如<code>seq(0, 10, by=0.5)</code>, 输出的是<code>0.0 0.5 1.0 ... 9.5 10.0</code>, 步长0.5的序列</li><li>例如<code>seq(5, 10, length=30)</code>，输出的是<code>5.000000  5.172414 ... 9.827586 10.000000</code>共30个数的序列</li></ul></li><li>查看序列长度<code>length()</code></li><li>创建和某个已知序列等长的序列<ul><li>例如<code>1:length(my_seq)</code>， 将符号<code>:</code>和<code>length（）</code>合用</li><li>使用<code>along.with</code>参数，例如<code>seq(along.with=my_seq)</code></li><li>使用内置函数<code>seq_along()</code>, 例如<code>seq_along(my_seq)</code></li></ul></li><li><code>rep()</code><ul><li>replicate: 重复</li><li>创建全零（n）序列, 例如<code>rep(0, times=30)</code></li><li>创建重复的向量组成的序列，例如<code>rep(c(1, 2, 3), times=10)</code></li><li>创建向量逐元素重复一定次数的序列，例如<code>rep(c(1, 2, 3), each=10)</code></li></ul></li></ul><p><img src="/2018/10/17/R介绍/rep.png" alt=""></p><h2 id="Lesson-4-Vectors"><a href="#Lesson-4-Vectors" class="headerlink" title="Lesson 4: Vectors"></a>Lesson 4: Vectors</h2><ul><li>关于向量<ul><li>是R中最简单也是最常见的数据结构</li><li>向量包含两种类型，一种是原子的（atomic）向量，其中只包含单一一种数据类型；另一种是列表（list）形式, 其中可以包含两种及以上种数据类型, 类型包括布尔型的TRUE， FALSE以及NA（not available）</li><li>例如<code>num_vect &lt;- c(0.5, 55, -10, 6)</code></li></ul></li><li>向量中元素和标量比较<ul><li>例如<code>tf &lt;- num_vect&lt;1</code>, 将比较<code>num_vect</code>中每个元素和1的大小，返回的是一个布尔型向量，<code>TRUE FALSE  TRUE FALSE</code></li></ul></li><li>逻辑运算<ul><li>与<code>&amp;</code></li><li>或<code>|</code></li><li>非<code>!</code></li></ul></li><li>字符串向量<ul><li>字符串使用双引号括起来, 例如<code>my_char &lt;- c(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;)</code></li><li>将字符串数组合成长字符串，<code>paste()</code>, 例如<code>paste(my_char, collapse=&quot; &quot;)</code>， 得到结果<code>&quot;My name is&quot;</code></li><li>字符串连接，例如<code>c(my_char, &quot;Leo&quot;)</code>，得到向量<code>&quot;My&quot;   &quot;name&quot; &quot;is&quot;   &quot;Leo&quot;</code></li></ul></li><li><p><code>paste()</code></p><ul><li><p>连接两个字符串为一个长字符串，例如<code>paste(&quot;Hello&quot;, &quot;world!&quot;, sep=&quot; &quot;)</code>, 得到<code>&quot;Hello world!&quot;</code></p></li><li><p>连接两个等长的向量，例如<code>paste(1:3, c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;)， sep=&quot;&quot;)</code>，得到<code>&quot;1X&quot; &quot;2Y&quot; &quot;3Z&quot;</code></p></li><li><p>配合内置字母向量使用，例如<code>paste(LETTERS, 1:4, sep=&quot;-&quot;)</code>, 得到<code>&quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; &quot;D-4&quot; &quot;E-1&quot; ... &quot;Y-1&quot; &quot;Z-2&quot;</code>。 其中<strong>LETTERS</strong>是预定义数组，表示英文的26个字母。这里的<code>1:4</code>向量数据类型被强制转换成字符串类型。</p></li></ul></li></ul><h2 id="Lesson-5-Missing-Values"><a href="#Lesson-5-Missing-Values" class="headerlink" title="Lesson 5: Missing Values"></a>Lesson 5: Missing Values</h2><ul><li>关于缺失值<ul><li>统计学中缺失值有重要的意义</li><li>不能🙅‍无视缺失值的存在，而是要研究缺失值背后潜在的模式或者导致值缺失的原因</li><li>R中使用<code>NA</code>表示缺失值，代表<code>not available</code>或者称为<code>missing</code></li></ul></li><li>创建含有缺失值的向量<ul><li>例如<code>c(44, NA, 5, NA)</code></li><li>NA运算依然是NA</li></ul></li><li>从标准正态分布随机抽样n个样本<ul><li><code>rnorm(1000)</code></li></ul></li><li>创建含1000个缺失值的序列<ul><li><code>rep(NA, 1000)</code></li></ul></li><li>数据抽样<code>sample()</code><ul><li>例如<code>my_data &lt;- sample(c(rnorm(1000),  rep(NA, 1000)), 100)</code>, 表示从长度为2000的序列中随机抽样100个值</li></ul></li><li>获取缺失值位置<ul><li><code>is.na()</code>, 例如<code>is.na(my_data)</code>, 返回一个大小为输入数据的布尔型数组，对应位置的TRUE和FALSE分别代表是否是缺失值</li></ul></li><li>统计缺失项<ul><li><code>sum()</code>, 例如<code>sum(is.na(my_data))</code></li></ul></li><li>NaN<ul><li>代表not a number</li><li>使用0/0, Inf/Inf, Inf-Inf可以生成</li></ul></li></ul><h2 id="Lesson-6-Subsetting-Vectors"><a href="#Lesson-6-Subsetting-Vectors" class="headerlink" title="Lesson 6: Subsetting Vectors"></a>Lesson 6: Subsetting Vectors</h2><ul><li><p>正整数索引</p><ul><li>R中的索引是从1开始的</li><li>使用方括号中加数字，可以访问数字索引位置的向量元素，例如<code>x[1:10]</code>表示向量<code>x</code>位置1到10上的元素</li></ul></li><li><p>索引是逻辑值（布尔值）</p><ul><li>例如<code>x[is.na(x)]</code>, 得到全NA数组，个数是x种NA的个数。（is.na(x)返回时布尔型数组，大小和x相同，在相应位置是TRUE或者是FALSE）</li><li>筛选数组中非NA的数，<code>x[!is.na(x)]</code></li><li>筛选数组中大于0的数， <code>y[y&gt;0]</code>; 注意，若数组中有NA，则该语句返回也会包含NA，在于NA属于占位符， NA&gt;0，得到的同样是NA。</li><li>若要从包含NA的数组中筛选出大于零的元素，使用<code>x[x&gt;0&amp;!is.na(x)]</code></li></ul></li><li><p>传入向量作为索引</p><ul><li>例如<code>x[c(3, 5, 7)]</code></li></ul></li><li><p>越界访问</p><ul><li>访问<code>x[0]</code>, 不报错返回<code>numeric(0)</code></li><li>访问越界的索引，例如<code>x[Inf]</code>，不报错，返回NA</li></ul></li><li><p>负整数索引</p><ul><li><code>x[c(-2, -10)]</code>,表示访问除了索引为2和10位置上的数之外的全部元素</li></ul></li><li><p>带有命名元素的数字向量</p><ul><li><blockquote><p>创建含有命名元素的数字向量</p><p><img src="/2018/10/17/R介绍/named-elements.png" alt=""></p></blockquote></li><li><blockquote><p>创建匿名的数字向量后使用<code>names()</code>赋予名称</p><p><img src="/2018/10/17/R介绍/unnamed.png" alt=""></p></blockquote></li><li><p>判断两个带名称的向量是否相等</p><ul><li>例如使用<code>identical(x=vect, y=vect2)</code>, 判断vect和vect2是否相等</li></ul></li><li><p>通过名称索引</p><ul><li>例如<code>vect[&quot;bar&quot;]</code>, <code>vect[c(&quot;bar&quot;, &quot;foo&quot;)]</code></li></ul></li></ul></li></ul><h2 id="Lesson-7-Matrices-and-Data-Frames"><a href="#Lesson-7-Matrices-and-Data-Frames" class="headerlink" title="Lesson 7: Matrices and Data Frames"></a>Lesson 7: Matrices and Data Frames</h2><h2 id="Lesson-8-Logic"><a href="#Lesson-8-Logic" class="headerlink" title="Lesson 8: Logic"></a>Lesson 8: Logic</h2><h2 id="Lesson-9-Functions"><a href="#Lesson-9-Functions" class="headerlink" title="Lesson 9: Functions"></a>Lesson 9: Functions</h2><h2 id="Lesson-10-lapply-and-sapply"><a href="#Lesson-10-lapply-and-sapply" class="headerlink" title="Lesson 10: lapply and sapply"></a>Lesson 10: lapply and sapply</h2><h2 id="Lesson-11-vapply-and-tapply"><a href="#Lesson-11-vapply-and-tapply" class="headerlink" title="Lesson 11: vapply and tapply"></a>Lesson 11: vapply and tapply</h2><h2 id="Lesson-12-Looking-at-Data"><a href="#Lesson-12-Looking-at-Data" class="headerlink" title="Lesson 12: Looking at Data"></a>Lesson 12: Looking at Data</h2><h2 id="Lesson-13-Simulation"><a href="#Lesson-13-Simulation" class="headerlink" title="Lesson 13: Simulation"></a>Lesson 13: Simulation</h2><h2 id="Lesson-14-Dates-and-Times"><a href="#Lesson-14-Dates-and-Times" class="headerlink" title="Lesson 14: Dates and Times"></a>Lesson 14: Dates and Times</h2><h2 id="Lesson-15-Basic-Graphics"><a href="#Lesson-15-Basic-Graphics" class="headerlink" title="Lesson 15: Basic Graphics"></a>Lesson 15: Basic Graphics</h2><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><h3 id="Warning-in-system-“sh-configure-win”-‘sh’-not-found-ERROR-configuration-failed-for-package-‘stringi’"><a href="#Warning-in-system-“sh-configure-win”-‘sh’-not-found-ERROR-configuration-failed-for-package-‘stringi’" class="headerlink" title="Warning in system(“sh ./configure.win”) : ‘sh’ not found ERROR: configuration failed for package ‘stringi’"></a>Warning in system(“sh ./configure.win”) : ‘sh’ not found ERROR: configuration failed for package ‘stringi’</h3></blockquote><p>Windows下安装<code>swirl</code>（一个统计学习，R学习等教程学习的R包，<a href="https://swirlstats.com/" target="_blank" rel="noopener">访问</a>），发现一个依赖的包<code>stringi</code>一直装不上去，后来查明是stringi的包版本过低，和最新版的R以及Rsutdio不匹配所致，所以去<a href="https://cran.r-project.org/web/packages/stringi/index.html，选择下载合适的新版本的stringi包（我下载的是windows，r-release" target="_blank" rel="noopener">https://cran.r-project.org/web/packages/stringi/index.html，选择下载合适的新版本的stringi包（我下载的是windows，r-release</a>:  stringi_1.1.7，<a href="https://cran.r-project.org/bin/windows/contrib/3.5/stringi_1.1.7.zip" target="_blank" rel="noopener">适合R3.5使用Windows版</a>），并解压到<code>R\R-3.5.1\library</code>下。</p><blockquote><h3 id="在markdown中如何在短引用着重号（backtick）中输入着重号-号，例如输入"><a href="#在markdown中如何在短引用着重号（backtick）中输入着重号-号，例如输入" class="headerlink" title="在markdown中如何在短引用着重号（backtick）中输入着重号` 号，例如输入?`:` "></a>在markdown中如何在<code>短引用</code>着重号（backtick）中输入着重号<code>` </code>号，例如输入<code>?`:` </code></h3></blockquote><ul><li><p>总的来说在就是单<code>` </code>对, 引用其他的。<figure class="highlight plain"><figcaption><span>```对，引用单`` ` ``引用的东西，本身靠三着重号对引用。```` ``` ````对引用双着重号引用的东西，本身靠连着的四引用号引用。以此类推</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ``` `` ?`:` `` ```, 这种效果的代码是 ````  ``` `` ?`:` `` ``` `</span><br></pre></td></tr></table></figure></p><ul><li><code>``` `` ?`:` `` ``` </code>这种效果的代码是<code>```` ``` `` ?`:` `` ``` ```` </code></li></ul></li><li><code>` </code>和<code>` </code>配对</li><li><code>`` </code>和<code>`` </code>配对</li><li><code>``` </code> 和<code>``` </code>配对</li><li>依此类推</li></ul><blockquote><h3 id="英文里常见的赞叹-夸人-๑•̀ㅂ•́-و✧表述有哪些"><a href="#英文里常见的赞叹-夸人-๑•̀ㅂ•́-و✧表述有哪些" class="headerlink" title="英文里常见的赞叹/夸人(๑•̀ㅂ•́)و✧表述有哪些"></a>英文里常见的赞叹/夸人(๑•̀ㅂ•́)و✧表述有哪些</h3></blockquote><ul><li>You are really on a roll!：你真走运</li><li>You nailed it! </li><li>Good job!</li><li>You are quite good my friend!</li><li>You are amazing!</li><li>You are the best!</li><li>Your dedication is inspiring!</li></ul><blockquote><p>最后更新时间：2018年10月20日</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;书籍这里使用的是Robert IKabacoff著王小宁，刘撷芯等译的的《R语言实践（第二版）》。&lt;/p&gt;
&lt;p&gt;编程环境使用的Rstudi
      
    
    </summary>
    
      <category term="Languages" scheme="https://www.blankspace.cn/categories/Languages/"/>
    
      <category term="R" scheme="https://www.blankspace.cn/categories/Languages/R/"/>
    
      <category term="Data Analysis with R" scheme="https://www.blankspace.cn/categories/Languages/R/Data-Analysis-with-R/"/>
    
      <category term="R in action" scheme="https://www.blankspace.cn/categories/Languages/R/Data-Analysis-with-R/R-in-action/"/>
    
    
      <category term="R" scheme="https://www.blankspace.cn/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>多元线性回归</title>
    <link href="https://www.blankspace.cn/2018/10/16/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>https://www.blankspace.cn/2018/10/16/多元线性回归/</id>
    <published>2018-10-16T08:38:28.000Z</published>
    <updated>2018-10-18T22:32:15.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><h3 id="多元线性回归的假设"><a href="#多元线性回归的假设" class="headerlink" title="多元线性回归的假设"></a>多元线性回归的假设</h3><p>n&gt;p， 样本个数要大于自变量的个数</p><h3 id="多元线性回归参数的最小二乘估计"><a href="#多元线性回归参数的最小二乘估计" class="headerlink" title="多元线性回归参数的最小二乘估计"></a>多元线性回归参数的最小二乘估计</h3><script type="math/tex; mode=display">x^Tx\hat\beta=x^Ty</script><p>分情况讨论：</p><ul><li><h3 id="x逆矩阵是否存在：直接带入-hat-beta-X-TX-1-X-Ty-，-hat-y-X-X-TX-X-Ty；-hat-y-Hy-，H矩阵具有等幂性。"><a href="#x逆矩阵是否存在：直接带入-hat-beta-X-TX-1-X-Ty-，-hat-y-X-X-TX-X-Ty；-hat-y-Hy-，H矩阵具有等幂性。" class="headerlink" title="x逆矩阵是否存在：直接带入$\hat\beta=(X^TX)^{-1}X^Ty$，$\hat y=X(X^TX)X^Ty；\hat y=Hy$，H矩阵具有等幂性。"></a>x逆矩阵是否存在：直接带入$\hat\beta=(X^TX)^{-1}X^Ty$，$\hat y=X(X^TX)X^Ty；\hat y=Hy$，H矩阵具有等幂性。</h3></li><li><p>逆矩阵不存在：偏最小二乘估计</p></li><li><p>奇异矩阵</p></li></ul><p>$\beta$服从正态分布</p><h3 id="标准化偏回归系数"><a href="#标准化偏回归系数" class="headerlink" title="标准化偏回归系数"></a>标准化偏回归系数</h3><p>不能直接由偏回归系数大小对于因变量线性影响的大小，需要计算标准化偏回归系数，即标准化偏回归系数。</p><p>推导过程</p><blockquote><p> 在解释的时候还是保留非标准化的的回归系数</p></blockquote><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><h4 id="多元回归模型的检验"><a href="#多元回归模型的检验" class="headerlink" title="多元回归模型的检验"></a>多元回归模型的检验</h4><ul><li>t检验</li><li>F检验，p值</li><li>矛盾，整体通过，单个不通过</li></ul><h4 id="多重共线性"><a href="#多重共线性" class="headerlink" title="多重共线性"></a>多重共线性</h4><p>自变量之间存在多重共线性</p><ul><li>产生原因</li><li>问题：<ul><li>参数估计不稳定</li><li>回归结果不稳定</li></ul></li><li>识别：<ul><li>计算各对自变量之间的相关系数</li><li>特征值判别</li></ul></li></ul><h4 id="多重共线现象"><a href="#多重共线现象" class="headerlink" title="多重共线现象"></a>多重共线现象</h4><p>相关性的假设检验</p><ol><li>特征根分析</li><li>条件数condition index</li></ol><h5 id="消除"><a href="#消除" class="headerlink" title="消除"></a>消除</h5><ol><li>变量筛选</li><li>增大样本容量</li><li>回归系数的有偏估计：岭回归，主成分分析，偏最小二乘</li></ol><blockquote><p>虽然均值不是无偏的，但是方差比较小，分布比较集中，则可能比无偏估计效果更好</p></blockquote><a id="more"></a><h2 id="变量选择逐步回归"><a href="#变量选择逐步回归" class="headerlink" title="变量选择逐步回归"></a>变量选择逐步回归</h2><h3 id="选择方法"><a href="#选择方法" class="headerlink" title="选择方法"></a>选择方法</h3><h4 id="全局择优法"><a href="#全局择优法" class="headerlink" title="全局择优法"></a>全局择优法</h4><ul><li>在残差平方和RSS上添加惩罚项</li><li>$C_p$准则</li><li>AIC准则&amp;BIC准则：评判指标，取值越小越好</li></ul><p>缺点</p><ul><li>组合爆炸</li></ul><h4 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h4><p>向前引入，向后剔除，逐步回归法</p><p>引入和剔除都是单向的。比较早剔除的变量在之后加入可能更好。</p><p>逐步回归，搜索空间加大。</p><h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>接近奇异，加入K指，使得接近奇异的程度减小。K=0时候，就是最小二乘法。</p><p>通过分析岭迹曲线选择K值。</p><p><strong>性质</strong>：</p><ol><li>性质1：有偏估计</li><li>…</li><li>…</li><li>…</li></ol><h4 id="岭迹分析"><a href="#岭迹分析" class="headerlink" title="岭迹分析"></a>岭迹分析</h4><p>用来解释自变量间的相关关系。</p><h4 id="参数k的选择"><a href="#参数k的选择" class="headerlink" title="参数k的选择"></a>参数k的选择</h4><h5 id="方差扩大因子"><a href="#方差扩大因子" class="headerlink" title="方差扩大因子"></a>方差扩大因子</h5><p>残差平方和来确定k</p><blockquote><p>k值得选择有一些人为的因素在其中。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;h3 id=&quot;一元线性回归&quot;&gt;&lt;a href=&quot;#一元线性回归&quot; class=&quot;headerlink&quot; title=&quot;一元线性回归&quot;&gt;&lt;/a&gt;一元线性回归&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;h3 id=&quot;多元线性回归&quot;&gt;&lt;a href=&quot;#多元线性回归&quot; class=&quot;headerlink&quot; title=&quot;多元线性回归&quot;&gt;&lt;/a&gt;多元线性回归&lt;/h3&gt;&lt;h3 id=&quot;多元线性回归的假设&quot;&gt;&lt;a href=&quot;#多元线性回归的假设&quot; class=&quot;headerlink&quot; title=&quot;多元线性回归的假设&quot;&gt;&lt;/a&gt;多元线性回归的假设&lt;/h3&gt;&lt;p&gt;n&amp;gt;p， 样本个数要大于自变量的个数&lt;/p&gt;
&lt;h3 id=&quot;多元线性回归参数的最小二乘估计&quot;&gt;&lt;a href=&quot;#多元线性回归参数的最小二乘估计&quot; class=&quot;headerlink&quot; title=&quot;多元线性回归参数的最小二乘估计&quot;&gt;&lt;/a&gt;多元线性回归参数的最小二乘估计&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
x^Tx\hat\beta=x^Ty&lt;/script&gt;&lt;p&gt;分情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;x逆矩阵是否存在：直接带入-hat-beta-X-TX-1-X-Ty-，-hat-y-X-X-TX-X-Ty；-hat-y-Hy-，H矩阵具有等幂性。&quot;&gt;&lt;a href=&quot;#x逆矩阵是否存在：直接带入-hat-beta-X-TX-1-X-Ty-，-hat-y-X-X-TX-X-Ty；-hat-y-Hy-，H矩阵具有等幂性。&quot; class=&quot;headerlink&quot; title=&quot;x逆矩阵是否存在：直接带入$\hat\beta=(X^TX)^{-1}X^Ty$，$\hat y=X(X^TX)X^Ty；\hat y=Hy$，H矩阵具有等幂性。&quot;&gt;&lt;/a&gt;x逆矩阵是否存在：直接带入$\hat\beta=(X^TX)^{-1}X^Ty$，$\hat y=X(X^TX)X^Ty；\hat y=Hy$，H矩阵具有等幂性。&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逆矩阵不存在：偏最小二乘估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;奇异矩阵&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\beta$服从正态分布&lt;/p&gt;
&lt;h3 id=&quot;标准化偏回归系数&quot;&gt;&lt;a href=&quot;#标准化偏回归系数&quot; class=&quot;headerlink&quot; title=&quot;标准化偏回归系数&quot;&gt;&lt;/a&gt;标准化偏回归系数&lt;/h3&gt;&lt;p&gt;不能直接由偏回归系数大小对于因变量线性影响的大小，需要计算标准化偏回归系数，即标准化偏回归系数。&lt;/p&gt;
&lt;p&gt;推导过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 在解释的时候还是保留非标准化的的回归系数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;假设检验&quot;&gt;&lt;a href=&quot;#假设检验&quot; class=&quot;headerlink&quot; title=&quot;假设检验&quot;&gt;&lt;/a&gt;假设检验&lt;/h3&gt;&lt;h4 id=&quot;多元回归模型的检验&quot;&gt;&lt;a href=&quot;#多元回归模型的检验&quot; class=&quot;headerlink&quot; title=&quot;多元回归模型的检验&quot;&gt;&lt;/a&gt;多元回归模型的检验&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;t检验&lt;/li&gt;
&lt;li&gt;F检验，p值&lt;/li&gt;
&lt;li&gt;矛盾，整体通过，单个不通过&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;多重共线性&quot;&gt;&lt;a href=&quot;#多重共线性&quot; class=&quot;headerlink&quot; title=&quot;多重共线性&quot;&gt;&lt;/a&gt;多重共线性&lt;/h4&gt;&lt;p&gt;自变量之间存在多重共线性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生原因&lt;/li&gt;
&lt;li&gt;问题：&lt;ul&gt;
&lt;li&gt;参数估计不稳定&lt;/li&gt;
&lt;li&gt;回归结果不稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;识别：&lt;ul&gt;
&lt;li&gt;计算各对自变量之间的相关系数&lt;/li&gt;
&lt;li&gt;特征值判别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;多重共线现象&quot;&gt;&lt;a href=&quot;#多重共线现象&quot; class=&quot;headerlink&quot; title=&quot;多重共线现象&quot;&gt;&lt;/a&gt;多重共线现象&lt;/h4&gt;&lt;p&gt;相关性的假设检验&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;特征根分析&lt;/li&gt;
&lt;li&gt;条件数condition index&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;消除&quot;&gt;&lt;a href=&quot;#消除&quot; class=&quot;headerlink&quot; title=&quot;消除&quot;&gt;&lt;/a&gt;消除&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;变量筛选&lt;/li&gt;
&lt;li&gt;增大样本容量&lt;/li&gt;
&lt;li&gt;回归系数的有偏估计：岭回归，主成分分析，偏最小二乘&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然均值不是无偏的，但是方差比较小，分布比较集中，则可能比无偏估计效果更好&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>data mining 2018-11-16</title>
    <link href="https://www.blankspace.cn/2018/10/16/data-mining-2018-11-16/"/>
    <id>https://www.blankspace.cn/2018/10/16/data-mining-2018-11-16/</id>
    <published>2018-10-16T06:05:13.000Z</published>
    <updated>2018-10-16T08:37:25.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>调查设计(统计学上的小例子)</p><ul><li>互斥</li><li>True/False</li></ul><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><ul><li>多：浪费；少，数据洪峰</li><li>pay as you go</li><li>软件，平台，基础infrastructure设施即服务</li></ul><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>串行$\to$并行</p><ul><li>aim：快</li><li>CPU$\to$GPU</li><li>适合图像$\to$通用计算</li></ul><blockquote><p>要有敏感性。</p><p>可以适度了解GPU编程。</p><p>release vs debug模式</p><p>xx实验室，xx公司人均有多少GPU卡</p></blockquote><ul><li>“智能”芯片</li><li>嵌入式计算设备：摄像头，MIC，等</li><li>并行也有代价</li><li>并非所有任务都要用并行</li></ul><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul><li>MapReduce<ul><li>map: 隐射(放)</li><li>reduce: 规约（收）</li></ul></li></ul><blockquote><p>数据+算法+计算=数据挖掘</p></blockquote><h3 id="没有免费的午餐原则"><a href="#没有免费的午餐原则" class="headerlink" title="没有免费的午餐原则"></a>没有免费的午餐原则</h3><ul><li>没有哪个算法始终是比别的好</li><li>考虑的因素：可解释性，计算复杂度，可用性</li><li>从简单到复杂</li><li>能做什么不能做什么<ul><li>例如，预测股票，彩票</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;调查设计(统计学上的小例子)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥&lt;/li&gt;
&lt;li&gt;True/False&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Data Science" scheme="https://www.blankspace.cn/categories/Data-Science/"/>
    
      <category term="Data Mining" scheme="https://www.blankspace.cn/categories/Data-Science/Data-Mining/"/>
    
    
      <category term="Data Mining" scheme="https://www.blankspace.cn/tags/Data-Mining/"/>
    
  </entry>
  
  <entry>
    <title>分布式存储</title>
    <link href="https://www.blankspace.cn/2018/10/15/distributed-storage/"/>
    <id>https://www.blankspace.cn/2018/10/15/distributed-storage/</id>
    <published>2018-10-15T11:19:38.000Z</published>
    <updated>2018-10-15T13:39:19.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul><li><p>基于Linux，“table-like”数据操作</p></li><li><p>命令行操作，正则表达式，awk, sort</p></li><li><p>单机能力不够，推广到多台服务器</p></li><li><p>缺陷：需要有管理者。但是我们希望是异步的。</p><ul><li>使用常驻进程，agent，每隔一段时间执行若干命令</li><li>将以前的controller push变成现在的分布式的pull命令</li></ul></li><li><p>性能分析</p><ul><li>性能瓶颈：IO，计算</li><li>分布式IO和计算</li></ul></li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>文件系统</p></li><li><p>布式文件系统</p></li><li><p>GFS 和 HDFS</p></li><li><p>其他方案</p></li></ul><h2 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h2><div class="table-container"><table><thead><tr><th>Type</th><th>Size</th><th>Speed</th></tr></thead><tbody><tr><td>resisters</td><td>thousands of bytes</td><td>1 CPU circle</td></tr><tr><td>Cache</td><td>MB level</td><td>快</td></tr><tr><td>Main memory</td><td>GB level</td><td>一般</td></tr><tr><td>Disk storage</td><td>TB level`</td><td>慢</td></tr></tbody></table></div><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>write</li><li>read</li><li>append</li><li>delete</li><li>modify</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="准测"><a href="#准测" class="headerlink" title="准测"></a>准测</h3><ul><li>能存大量的信息，理论上没有上限</li><li>information must survive the processed using it</li><li>concurrent access to multiple processes</li></ul><h3 id="文件系统解决方案"><a href="#文件系统解决方案" class="headerlink" title="文件系统解决方案"></a>文件系统解决方案</h3><ul><li>storage information on disks in units called files</li><li>files are <strong>persistent（持久化）</strong></li><li>files are managed by the OS</li></ul><h4 id="Naming-命名"><a href="#Naming-命名" class="headerlink" title="Naming 命名"></a>Naming 命名</h4><ul><li><p>创建文件并命名</p></li><li><p>不同OS有不同的规则</p></li></ul><h4 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h4><ul><li><p>序列结构（遍历），但是Byte Sequence: unstructured</p></li><li><p>复杂的结构：例如树形结构</p><ul><li>变长记录</li><li>OS specific meaning of each file</li></ul></li></ul><h3 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h3><p><strong>如何实现文件系统呢？</strong></p><ul><li>包含以下方面<ul><li>volumes/partitions（磁盘规划）</li><li>directories（link filenames to file “structure”)</li><li>list of blocks</li><li>高级需求，例如权限管理等</li></ul></li></ul><h4 id="Structure-to-data"><a href="#Structure-to-data" class="headerlink" title="Structure to data"></a>Structure to data</h4><ul><li>创建文件<ul><li>find space in the filesystem, add directory entry</li></ul></li><li>writing in a file<ul><li>write pointer</li></ul></li><li>reading a file<ul><li>read pointer</li></ul></li></ul><h4 id="Data-layout"><a href="#Data-layout" class="headerlink" title="Data layout"></a>Data layout</h4><ul><li><p>file system is stored on disks</p><ul><li><p>disk is divided into 1 or more partitions</p></li><li><p>sector 0 of disk called Mater Boot Record(MBR)</p></li><li><p>end of MBR has partition table（start &amp; end address of partitions）</p></li></ul></li></ul><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ul><li>连续存储：优点，简单，读写性能比较好；缺点，改动效率不高，碎片太多，用户需要知道文件大小。</li><li>Linked List Allocation<ul><li>Each file is stored as linked list of blocks<ul><li>first word of each block points to next block</li><li>rest of disk block is file data</li></ul></li><li>优点<ul><li>只需要维护第一个block信息</li></ul></li><li>缺点<ul><li>随机访问开销大</li><li>overheads of pointers</li></ul></li></ul></li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li>根据情况使用，永久存储适合连续存储结构</li><li>经常变更：列表结构</li><li>索引结构：一个指针能够指向多个blocks</li></ul><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><h4 id="Directory-Tree"><a href="#Directory-Tree" class="headerlink" title="Directory Tree"></a>Directory Tree</h4><ul><li>/<ul><li>bin<ul><li>pwd, cd, ls</li></ul></li><li>sbin: root<ul><li>ifup</li><li>ifconfig</li><li>ifdown</li></ul></li><li>home<ul><li>home directory</li></ul></li><li>var<ul><li>log files</li><li>spools</li></ul></li><li>tmp<ul><li>temp files</li></ul></li><li>root<ul><li>root’s home</li></ul></li><li>usr<ul><li>user program files</li></ul></li><li>opt<ul><li>optional</li></ul></li></ul></li></ul><p><img src="/2018/10/15/distributed-storage/Linux-Directory-Structure.jpeg" alt="linux文件系统"> </p><h2 id="Distributed-File-System"><a href="#Distributed-File-System" class="headerlink" title="Distributed File System"></a>Distributed File System</h2><h3 id="DFS-Goals"><a href="#DFS-Goals" class="headerlink" title="DFS Goals"></a>DFS Goals</h3><ul><li><strong>location transparency</strong></li><li>concurrency(并发性) transparency</li><li><strong>failure transparency</strong></li><li>heterogeneity(异构性)</li><li>scalability(可扩展性)</li></ul><h3 id="DFS-structure"><a href="#DFS-structure" class="headerlink" title="DFS structure"></a>DFS structure</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>meta server/name node：维护结构，命名<ul><li>data node：负责存储</li><li>data node</li><li>….</li></ul></li></ul><h4 id="File-VS-Chunk"><a href="#File-VS-Chunk" class="headerlink" title="File VS. Chunk"></a>File VS. Chunk</h4><ul><li>对外提供文件名访问</li><li>文件对应chunk的id</li><li>定义replication（冗余）</li><li>整个DFS就是构建映射</li></ul><p>可能的过程</p><ol><li>client请求</li><li>通过协议，client收到block/chunk信息</li><li>client请求要访问的block/chunk</li><li>返回哪些name node的那些地方存在有相应的block/chunk</li><li>client请求name node上的block/chunk</li><li>通过网络（socket）返回文件（流）</li></ol><h4 id="“Rack”-awareness"><a href="#“Rack”-awareness" class="headerlink" title="“Rack” awareness"></a>“Rack” awareness</h4><ul><li>core switch<ul><li>core switch<ul><li>rack switch</li><li>datanode (最容易访问的位置)</li><li>datanode</li><li>…</li></ul></li><li>core switch</li><li>…</li></ul></li></ul><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul><li>随机读</li><li>并行读</li><li>throughput awareness</li><li>smart client</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除映射</li><li>定期垃圾回收</li></ul><h4 id="优点和局限"><a href="#优点和局限" class="headerlink" title="优点和局限"></a>优点和局限</h4><ul><li>fault tolerance, namenode在线热备份</li><li>custom designed(例如，定义chunk，减少访问次数)</li></ul><p>缺点：只在特定的条件下有用。安全机制。</p><div class="table-container"><table><thead><tr><th>FS</th><th>DFS</th></tr></thead><tbody><tr><td>organized with a structure</td><td>same as FS</td></tr><tr><td>index+data</td><td>namenode+datanode</td></tr><tr><td>smart FS</td><td>simple DFS+smart client</td></tr></tbody></table></div><p>相当于把FS中的“聪明的”工作搬到client上了。</p><h3 id="阅读任务"><a href="#阅读任务" class="headerlink" title="阅读任务"></a>阅读任务</h3><h4 id="DHT（分布式哈希表）"><a href="#DHT（分布式哈希表）" class="headerlink" title="DHT（分布式哈希表）"></a>DHT（分布式哈希表）</h4><h4 id="GFH"><a href="#GFH" class="headerlink" title="GFH"></a>GFH</h4><p>阅读材料。（pipeline， reduplication）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于Linux，“table-like”数据操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令行操作，正则表达式，awk, so
      
    
    </summary>
    
      <category term="Data Science" scheme="https://www.blankspace.cn/categories/Data-Science/"/>
    
      <category term="Big Data" scheme="https://www.blankspace.cn/categories/Data-Science/Big-Data/"/>
    
      <category term="Big Data System" scheme="https://www.blankspace.cn/categories/Data-Science/Big-Data/Big-Data-System/"/>
    
    
      <category term="Linux" scheme="https://www.blankspace.cn/tags/Linux/"/>
    
      <category term="Distributed Storage" scheme="https://www.blankspace.cn/tags/Distributed-Storage/"/>
    
  </entry>
  
  <entry>
    <title>线性分类器</title>
    <link href="https://www.blankspace.cn/2018/10/12/pattern-recognition-ch4/"/>
    <id>https://www.blankspace.cn/2018/10/12/pattern-recognition-ch4/</id>
    <published>2018-10-12T10:25:09.000Z</published>
    <updated>2018-10-13T11:10:14.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性判别函数的基本概念"><a href="#线性判别函数的基本概念" class="headerlink" title="线性判别函数的基本概念"></a>线性判别函数的基本概念</h2><script type="math/tex; mode=display"></script><script type="math/tex; mode=display">g(x)=w^Tx+\omega_0</script><h2 id="Fisher-判别分析"><a href="#Fisher-判别分析" class="headerlink" title="Fisher 判别分析"></a>Fisher 判别分析</h2><p>​    </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性判别函数的基本概念&quot;&gt;&lt;a href=&quot;#线性判别函数的基本概念&quot; class=&quot;headerlink&quot; title=&quot;线性判别函数的基本概念&quot;&gt;&lt;/a&gt;线性判别函数的基本概念&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
g(x)=w^Tx+\omega_0&lt;/script&gt;&lt;h2 id=&quot;Fisher-判别分析&quot;&gt;&lt;a href=&quot;#Fisher-判别分析&quot; class=&quot;headerlink&quot; title=&quot;Fisher 判别分析&quot;&gt;&lt;/a&gt;Fisher 判别分析&lt;/h2&gt;&lt;p&gt;​    &lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://www.blankspace.cn/categories/AI/"/>
    
      <category term="Pattern Recognition" scheme="https://www.blankspace.cn/categories/AI/Pattern-Recognition/"/>
    
    
      <category term="Pattern Recognition" scheme="https://www.blankspace.cn/tags/Pattern-Recognition/"/>
    
  </entry>
  
  <entry>
    <title>（汇总）关于Python的若干问题</title>
    <link href="https://www.blankspace.cn/2018/10/10/misc-pyerrors/"/>
    <id>https://www.blankspace.cn/2018/10/10/misc-pyerrors/</id>
    <published>2018-10-10T03:49:34.000Z</published>
    <updated>2018-10-15T11:19:43.623Z</updated>
    
    <content type="html"><![CDATA[<p>保存<code>ipython</code>交互式会话内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%save test.py 1-xxx</span><br></pre></td></tr></table></figure><p>Ubuntu安装Anaconda后使其生效</p><p>将下面写入<code>.bashrc</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH="~/Anaconda/bin:$PATH"</span><br><span class="line">. /home/&lt;path_to_anaconda&gt;/Anaconda/etc/profile.d/conda.sh</span><br><span class="line">conda activate</span><br></pre></td></tr></table></figure><p>然后使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基于 python3.6 创建一个名为test_py3 的环境</span></span><br><span class="line">conda create --name py36 python=3.6 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于 python2.7 创建一个名为test_py2 的环境</span></span><br><span class="line">conda create --name py27 python=2.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 激活 <span class="built_in">test</span> 环境</span></span><br><span class="line">activate py36  # windows</span><br><span class="line">source activate py36 # linux/mac</span><br></pre></td></tr></table></figure><p><img src="/2018/10/10/misc-pyerrors/conda-not-found.png" alt="conda not found"></p><p><img src="/2018/10/10/misc-pyerrors/conda-not-found-solve.png" alt="conda-not-found-solve"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">export</span> PATH=~/Anaconda/bin:<span class="variable">$PATH</span>` &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><hr><p><img src="/2018/10/10/misc-pyerrors/创建虚拟环境.png" alt=""></p><p><img src="/2018/10/10/misc-pyerrors/激活虚拟环境.png" alt="激活虚拟环境"></p><hr><p>生成<code>requirements.txt</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保存&lt;code&gt;ipython&lt;/code&gt;交互式会话内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre
      
    
    </summary>
    
      <category term="Misc" scheme="https://www.blankspace.cn/categories/Misc/"/>
    
      <category term="Errors" scheme="https://www.blankspace.cn/categories/Misc/Errors/"/>
    
    
      <category term="Python" scheme="https://www.blankspace.cn/tags/Python/"/>
    
      <category term="Errors" scheme="https://www.blankspace.cn/tags/Errors/"/>
    
      <category term="Bugs" scheme="https://www.blankspace.cn/tags/Bugs/"/>
    
  </entry>
  
  <entry>
    <title>Chrome Shortcuts</title>
    <link href="https://www.blankspace.cn/2018/10/10/chrome-shortcuts/"/>
    <id>https://www.blankspace.cn/2018/10/10/chrome-shortcuts/</id>
    <published>2018-10-10T03:17:28.000Z</published>
    <updated>2018-10-10T11:34:37.271Z</updated>
    
    <content type="html"><![CDATA[<p>通过快捷键来使用Chrome，看起来专业一丢丢。</p><h2 id="声明和引用"><a href="#声明和引用" class="headerlink" title="声明和引用"></a>声明和引用</h2><blockquote><p>来源：<a href="https://support.google.com/chrome/answer/157179?hl=en" target="_blank" rel="noopener">https://support.google.com/chrome/answer/157179?hl=en</a></p></blockquote><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>用途</th></tr></thead><tbody><tr><td><strong>F12 或 Ctrl+Shift+J</strong></td><td>打开和关闭开发者工具</td></tr><tr><td><strong>Alt + F4</strong></td><td>关闭当前窗口</td></tr><tr><td><strong>Ctrl+W 或 Ctrl+F4</strong></td><td>关闭当前标签</td></tr><tr><td><strong>Ctrl+Tap</strong></td><td>转到下个打开的标签</td></tr><tr><td><strong>Ctrl+Shift+Tap</strong></td><td>转到上个打开的标签</td></tr><tr><td><strong>Ctrl+9</strong></td><td>转到最后一个打开的标签</td></tr><tr><td><strong>Alt+f</strong></td><td>打开菜单</td></tr><tr><td><strong>Ctrl+f</strong></td><td>搜索关键词</td></tr><tr><td><strong>Ctrl+e</strong></td><td>新的搜索</td></tr><tr><td><strong>Alt+Home</strong></td><td>打开主页</td></tr><tr><td><strong>Ctrl+Alt+Del</strong></td><td>清除缓存</td></tr><tr><td><strong>Ctrl+r 或 F5</strong></td><td>刷新当前页面</td></tr></tbody></table></div><h2 id="Windows-amp-Linux"><a href="#Windows-amp-Linux" class="headerlink" title="Windows &amp; Linux"></a>Windows &amp; Linux</h2><h3 id="标签页和窗口快捷键"><a href="#标签页和窗口快捷键" class="headerlink" title="标签页和窗口快捷键"></a>标签页和窗口快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>Ctrl + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>Ctrl + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>Ctrl + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>Ctrl + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>Ctrl + Tab</strong> 或 <strong>Ctrl + PgDn</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>Ctrl + Shift + Tab</strong> 或 <strong>Ctrl + PgUp</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>Ctrl + 1</strong> 到 <strong>Ctrl + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>Ctrl + 9</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>Alt + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>Alt + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页</td><td><strong>Ctrl + w</strong> 或 <strong>Ctrl + F4</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Ctrl + Shift + w</strong></td></tr><tr><td>最小化当前窗口</td><td><strong>Alt + 空格键 + n</strong></td></tr><tr><td>最大化当前窗口</td><td><strong>Alt + 空格键 + x</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Alt + F4</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>Ctrl + Shift + q</strong></td></tr></tbody></table></div><h3 id="Chrome功能快捷键"><a href="#Chrome功能快捷键" class="headerlink" title="Chrome功能快捷键"></a>Chrome功能快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开 Chrome 菜单</td><td><strong>Alt + f</strong> 或 <strong>Alt + e</strong> 或 <strong>F10 + Enter 键</strong></td></tr><tr><td><del>显示或隐藏书签栏</del></td><td><del><strong>Ctrl + Shift + b</strong></del></td></tr><tr><td>打开书签管理器</td><td><strong>Ctrl + Shift + o</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>Ctrl + h</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>Ctrl + j</strong></td></tr><tr><td>打开 Chrome 任务管理器</td><td><strong>Shift + Esc</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的第一项上</td><td><strong>Shift + Alt + t</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的最后一项上</td><td><strong>F10</strong></td></tr><tr><td>将焦点移到未聚焦于的对话框（如果显示）中</td><td><strong>F6</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>Ctrl + f</strong> 或 <strong>F3</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>Ctrl + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>Ctrl + Shift + g</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>Ctrl + Shift + j</strong> 或 <strong>F12</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>Ctrl + Shift + Delete</strong></td></tr><tr><td>在新标签页中打开 Chrome 帮助中心</td><td><strong>F1</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td><td><strong>Ctrl + Shift + m</strong></td></tr><tr><td>打开反馈表单</td><td><strong>Alt + Shift + i</strong></td></tr></tbody></table></div><h3 id="地址栏快捷键"><a href="#地址栏快捷键" class="headerlink" title="地址栏快捷键"></a>地址栏快捷键</h3><p>在地址栏中可使用以下快捷键：</p><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Ctrl + Enter</strong> 键</td></tr><tr><td>打开新的标签页并执行 Google 搜索</td><td>输入搜索字词并按 <strong>Alt + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>Ctrl + l</strong>、<strong>Alt + d</strong> 或 <strong>F6</strong></td></tr><tr><td>从页面中的任意位置搜索</td><td><strong>Ctrl + k</strong> 或 <strong>Ctrl + e</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + Delete</strong> 键</td></tr></tbody></table></div><h3 id="网页快捷键"><a href="#网页快捷键" class="headerlink" title="网页快捷键"></a>网页快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>Ctrl + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>Ctrl + s</strong></td></tr><tr><td>重新加载当前网页</td><td><strong>F5</strong> 或 <strong>Ctrl + r</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>Shift + F5</strong> 或 <strong>Ctrl + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Chrome 打开计算机中的文件</td><td>按住 <strong>Ctrl + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>Ctrl + u</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>Ctrl + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>Ctrl + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>F11</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>Ctrl 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>Ctrl 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>Ctrl + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong>或 <strong>PgDn</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong>或 <strong>PgUp</strong></td></tr><tr><td>转到网页顶部</td><td><strong>首页</strong></td></tr><tr><td>转到网页底部</td><td><strong>末尾</strong></td></tr><tr><td>在网页上水平滚动</td><td>按住 <strong>Shift</strong> 键并滚动鼠标滚轮</td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Ctrl + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Ctrl + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Ctrl + Backspace</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr></tbody></table></div><h3 id="鼠标快捷键"><a href="#鼠标快捷键" class="headerlink" title="鼠标快捷键"></a>鼠标快捷键</h3><p>以下快捷键要求您使用鼠标：</p><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>Ctrl</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>Ctrl + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Alt</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头 或“前进”箭头 ，或者点击（按住鼠标按键别松手）“后退”箭头  或“前进”箭头</td></tr><tr><td>在最大化模式和窗口模式间切换</td><td>双击标签栏的空白区域</td></tr><tr><td>放大网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向上滚动鼠标滚轮</td></tr><tr><td>缩小网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向下滚动鼠标滚轮</td></tr></tbody></table></div><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><h3 id="标签页和窗口快捷键-1"><a href="#标签页和窗口快捷键-1" class="headerlink" title="标签页和窗口快捷键"></a>标签页和窗口快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>⌘ + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>⌘ + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>⌘ + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>⌘ + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>⌘ + Option + 向右箭头键</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>⌘ + Option + 向左箭头键</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>⌘ + 1</strong> 到 <strong>⌘ + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>⌘ + 9</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>⌘ + [</strong> 或 <strong>⌘ + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>⌘ + ]</strong> 或 <strong>⌘ + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页或弹出式窗口</td><td><strong>⌘ + w</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>⌘ + Shift + w</strong></td></tr><tr><td>最小化窗口</td><td><strong>⌘ + m</strong></td></tr><tr><td>隐藏 Google Chrome</td><td><strong>⌘ + h</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>⌘ + q</strong></td></tr></tbody></table></div><h3 id="Chrome功能快捷键-1"><a href="#Chrome功能快捷键-1" class="headerlink" title="Chrome功能快捷键"></a>Chrome功能快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>显示或隐藏书签栏</td><td><strong>⌘ + Shift + b</strong></td></tr><tr><td>打开书签管理器</td><td><strong>⌘ + Option + b</strong></td></tr><tr><td>在新标签页中打开“设置”页</td><td><strong>⌘ + ,</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>⌘ + y</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>⌘ + Shift + j</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>⌘ + f</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>⌘ + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>⌘ + Shift + g</strong></td></tr><tr><td>打开查找栏后，搜索选定文本</td><td><strong>⌘ + e</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>⌘ + Option + i</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>⌘ + Shift + Delete</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td></tr></tbody></table></div><h3 id="地址栏快捷键-1"><a href="#地址栏快捷键-1" class="headerlink" title="地址栏快捷键"></a>地址栏快捷键</h3><p>在地址栏中可使用以下快捷键：</p><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Enter</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在新标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Shift + Enter</strong> 键</td></tr><tr><td>在新的后台标签页中打开网站</td><td>输入网址并按 <strong>⌘ + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>⌘ + l</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + fn + Delete</strong> 键</td></tr></tbody></table></div><h3 id="网页快捷键-1"><a href="#网页快捷键-1" class="headerlink" title="网页快捷键"></a>网页快捷键</h3><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>⌘ + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>⌘ + s</strong></td></tr><tr><td>打开“页面设置”对话框</td><td><strong>⌘ + Option + p</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>⌘ + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Google Chrome 打开计算机中的文件</td><td>按住 <strong>⌘ + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>⌘ + Option + u</strong></td></tr><tr><td>打开 JavaScript 控制台</td><td><strong>⌘ + Option + j</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>⌘ + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>⌘ + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>⌘ + Ctrl + f</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>⌘ 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>⌘ 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>⌘ + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong></td></tr><tr><td>搜索网络</td><td><strong>⌘ + Option + f</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Option + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Option + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Option + Delete</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>⌘ + Shift + h</strong></td></tr></tbody></table></div><h3 id="鼠标快捷键-1"><a href="#鼠标快捷键-1" class="headerlink" title="鼠标快捷键"></a>鼠标快捷键</h3><p>以下快捷键要求您使用鼠标：</p><div class="table-container"><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>⌘</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>⌘ + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Option</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头  或“前进”箭头 ，或者点击（按住鼠标按键别松手）“后退”箭头 或“前进”箭头</td></tr><tr><td>将窗口高度最大化</td><td>双击标签栏的空白区域</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过快捷键来使用Chrome，看起来专业一丢丢。&lt;/p&gt;
&lt;h2 id=&quot;声明和引用&quot;&gt;&lt;a href=&quot;#声明和引用&quot; class=&quot;headerlink&quot; title=&quot;声明和引用&quot;&gt;&lt;/a&gt;声明和引用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;来源：&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Misc" scheme="https://www.blankspace.cn/categories/Misc/"/>
    
      <category term="Tools &amp; Tips" scheme="https://www.blankspace.cn/categories/Misc/Tools-Tips/"/>
    
      <category term="Shortcuts" scheme="https://www.blankspace.cn/categories/Misc/Tools-Tips/Shortcuts/"/>
    
    
      <category term="Chrome" scheme="https://www.blankspace.cn/tags/Chrome/"/>
    
      <category term="Shortcuts" scheme="https://www.blankspace.cn/tags/Shortcuts/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）Shell命令和cluster建立和使用</title>
    <link href="https://www.blankspace.cn/2018/10/08/bigdata-system-hw01/"/>
    <id>https://www.blankspace.cn/2018/10/08/bigdata-system-hw01/</id>
    <published>2018-10-08T15:16:59.000Z</published>
    <updated>2018-10-12T10:25:08.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul><li>使用一个Linux server</li><li>使用一个a linux cluster</li><li>mapreduce and spark</li></ul><h3 id="协议和工具"><a href="#协议和工具" class="headerlink" title="协议和工具"></a>协议和工具</h3><p>ssh工具</p><ul><li>putty</li><li>xshell</li></ul><h3 id="获得数据"><a href="#获得数据" class="headerlink" title="获得数据"></a>获得数据</h3><ul><li>scp, winscp</li><li>sshfs</li><li>ftp</li><li>wget, curl</li></ul><h3 id="处理结构化的数据"><a href="#处理结构化的数据" class="headerlink" title="处理结构化的数据"></a>处理结构化的数据</h3><ul><li>awk<br>  awk ‘{print $3 “\t” $4} filename</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> awk '&#123;print $2 "\t" $3&#125;' a.txt</span><br><span class="line">1       1</span><br><span class="line">2       2</span><br><span class="line">3       3</span><br><span class="line">4       4</span><br><span class="line">2       3</span><br></pre></td></tr></table></figure><h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p><code>ls -lh</code></p><ul><li>wc : word count</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018211154@ubuntu:~$ wc -l wc_dataset.txt </span><br><span class="line">536700000 wc_dataset.txt</span><br></pre></td></tr></table></figure><h4 id="查看部分数据"><a href="#查看部分数据" class="headerlink" title="查看部分数据"></a>查看部分数据</h4><ul><li>more less，以分页形式查看文件</li><li>head tail</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~$ tail -n 20 wc_dataset.txt </span><br><span class="line">words</span><br><span class="line">of</span><br><span class="line">the</span><br><span class="line">old</span><br><span class="line">Negro</span><br><span class="line">spiritual</span><br><span class="line">Free</span><br><span class="line">at</span><br><span class="line">last</span><br><span class="line">free</span><br><span class="line">at</span><br><span class="line">last</span><br><span class="line">Thank</span><br><span class="line">God</span><br><span class="line">Almighty</span><br><span class="line">we</span><br><span class="line">are</span><br><span class="line">free</span><br><span class="line">at</span><br><span class="line">last</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10000 wc_dataset.txt | head -n 100</span><br></pre></td></tr></table></figure><ul><li>cat 连接</li></ul><h3 id="对于表格数据的操作"><a href="#对于表格数据的操作" class="headerlink" title="对于表格数据的操作"></a>对于表格数据的操作</h3><ul><li>cat: 打印到标准输出<ul><li>cat a  b &gt; c :列方向合并a,b到c</li></ul></li><li>paste: 行方向的合并<br> grep -c：查找,<code>grep -c pattern file</code>, c是count。</li><li>正则表达式</li><li>^开头</li><li>$结尾</li><li><code>*</code>所有</li><li><code>[]</code></li><li>{}</li><li>?</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018211154@ubuntu:~$ grep -c "^$" wc_dataset.txt </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><code>/a/{++cnt} END {print &quot;Count = &quot;, cnt}</code> filename<br>/a 查找</p><p>`awk ‘!($0 in arr) {arr[$0]; print}’ filename</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li>排序sor</li><li>unique</li></ul><h2 id="Running-commands-on-a-single-machine"><a href="#Running-commands-on-a-single-machine" class="headerlink" title="Running commands on a single machine"></a>Running commands on a single machine</h2><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>运行多个进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.sh &amp;</span><br><span class="line">b.sh &amp;</span><br><span class="line">c.sh &amp;</span><br><span class="line">wait</span><br></pre></td></tr></table></figure><p>编写<code>.sh</code></p><h3 id="ps-top"><a href="#ps-top" class="headerlink" title="ps, top"></a>ps, top</h3><p>查看进程</p><p>crontab： crontab -e</p><h2 id="Using-a-linux-cluster"><a href="#Using-a-linux-cluster" class="headerlink" title="Using a linux cluster"></a>Using a linux cluster</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><ul><li><p>ssh machine command</p></li><li><p>dsh, pdsh</p></li></ul><p>将私钥注册，就不需要输入密码。</p><h2 id="Using-a-linux-cluster-1"><a href="#Using-a-linux-cluster-1" class="headerlink" title="Using a linux cluster"></a>Using a linux cluster</h2><ul><li><p>pusll-based control<br>  create an agent on each server, driven by crontab</p><p>  eg. wget and run</p></li><li><p>creat a central control </p></li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><h3 id="实验材料"><a href="#实验材料" class="headerlink" title="实验材料"></a>实验材料</h3><p><strong>实验平台</strong>：Windows 10 专业版 64-bit (10.0, Build 16299)。8192MB RAM。<br><strong>处理器</strong>：Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz (8 CPUs), ~2.8GHz。<strong>数据集</strong>：本实验选取的是Kaggle上的<code>facebook-recruiting-iii-keyword-extraction</code>公开数据集，文件大小为3GB，数据集详情见后文。</p><p><img src="/2018/10/08/bigdata-system-hw01/data01.png" alt="使用SCP上传数据"></p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p><strong>Kaggle</strong>是当今世界上最大的数据科学竞赛和学习社</p><ol><li>获取Kaggle账号</li><li>下载数据集</li></ol><p>每个数据集在下载之前都要阅读和同意其声明，确定之后就可以开始通过Kaggle命令来下载数据集。</p><p>对于首次下载来说，首先确保自己的电脑</p><h3 id="单机Linux实验"><a href="#单机Linux实验" class="headerlink" title="单机Linux实验"></a>单机Linux实验</h3><p><img src="/2018/10/08/bigdata-system-hw01/scp01.png" alt="使用SCP上传数据"></p><p><img src="/2018/10/08/bigdata-system-hw01/ls01.png" alt="cd, ls指令"></p><h3 id="多机协同实验"><a href="#多机协同实验" class="headerlink" title="多机协同实验"></a>多机协同实验</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Outline&quot;&gt;&lt;a href=&quot;#Outline&quot; class=&quot;headerlink&quot; title=&quot;Outline&quot;&gt;&lt;/a&gt;Outline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用一个Linux server&lt;/li&gt;
&lt;li&gt;使用一个a linux cluste
      
    
    </summary>
    
      <category term="Data Science" scheme="https://www.blankspace.cn/categories/Data-Science/"/>
    
      <category term="Big Data" scheme="https://www.blankspace.cn/categories/Data-Science/Big-Data/"/>
    
      <category term="Big Data System" scheme="https://www.blankspace.cn/categories/Data-Science/Big-Data/Big-Data-System/"/>
    
    
      <category term="Shell" scheme="https://www.blankspace.cn/tags/Shell/"/>
    
      <category term="ssh" scheme="https://www.blankspace.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）Shell命令快速参考</title>
    <link href="https://www.blankspace.cn/2018/10/08/linux-shell-rush-01/"/>
    <id>https://www.blankspace.cn/2018/10/08/linux-shell-rush-01/</id>
    <published>2018-10-08T01:24:03.000Z</published>
    <updated>2018-10-16T13:46:48.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ls-cd-pwd"><a href="#ls-cd-pwd" class="headerlink" title="ls, cd, pwd"></a>ls, cd, pwd</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ol><li><p>命令格式<br><code>ls</code> : list</p><blockquote><p>ls <option> <dir></dir></option></p></blockquote></li><li><p>常用参数<br>使用<code>man ls</code>查看是坠吼的，笔记里就懒得写那么多了。常用的有：</p></li></ol><ul><li><code>-a</code>: <code>--all</code>, 显示全部的文件，包括以<code>.</code>开头的隐藏文件。</li><li><code>-l</code>: 长列表的形式呈现文件</li><li><code>-t</code>：以文档修改时间排序</li><li><code>-h</code>：列出人能读懂的文件大小</li><li><code>-d</code>：将目录也像问价那样列出来</li></ul><ol><li>使用范例<br><strong>1)</strong> 参数可以每个加<code>-</code>列出，也可以组合，只用一个<code>-</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx@ubuntu:~$ ls -a -l -t -h</span><br><span class="line">xxx@ubuntu:~$ ls -alth</span><br></pre></td></tr></table></figure></li></ol><p><strong>2)</strong> 列出当前目录哪些文件名(比如以<code>d</code>开头)的文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l d*</span><br></pre></td></tr></table></figure></p><p>字符串替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ tmp="c:/windows/system32/dirviers"</span><br><span class="line">(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $&#123;tmp/windows/linux&#125;</span><br><span class="line">c:/linux/system32/dirviers</span><br></pre></td></tr></table></figure><p>${变量/查找/替换值} 一个“/”表示替换第一个，”//”表示替换所有,当查找中出现了：”/”请加转义符”\/”表示。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $&#123;tmp//\//*&#125;</span><br><span class="line">c:*windows*system32*dirviers</span><br></pre></td></tr></table></figure><p>将所有斜杠<code>/</code>转换成<code>\</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ tmp=($&#123;tmp//\//\\&#125;)</span><br><span class="line">(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $tmp</span><br><span class="line">c:\windows\system32\dirviers</span><br></pre></td></tr></table></figure><p>移动某种类型的文件</p><p>mv *.txt new_dir/</p><p>按照一定条件输出某文件的某些行到另外的文件</p><p> awk ‘NR==2{print $0 &gt;&gt; “tmp.txt”}’ py27_stars_count_1_to_100.txt </p><p>单引号里面是指令，双引号表示字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'NR1&#123;print $0 &gt;&gt; "temp_result.txt"&#125; FNR2&#123;print $0 &gt;&gt; "temp_result.txt"&#125;'</span> &#123;1..5&#125;.txt</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ls-cd-pwd&quot;&gt;&lt;a href=&quot;#ls-cd-pwd&quot; class=&quot;headerlink&quot; title=&quot;ls, cd, pwd&quot;&gt;&lt;/a&gt;ls, cd, pwd&lt;/h2&gt;&lt;h3 id=&quot;ls&quot;&gt;&lt;a href=&quot;#ls&quot; class=&quot;headerlink&quot; title=&quot;ls&quot;&gt;&lt;/a&gt;ls&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令格式&lt;br&gt;&lt;code&gt;ls&lt;/code&gt; : list&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ls &lt;option&gt; &lt;dir&gt;&lt;/dir&gt;&lt;/option&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常用参数&lt;br&gt;使用&lt;code&gt;man ls&lt;/code&gt;查看是坠吼的，笔记里就懒得写那么多了。常用的有：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;: &lt;code&gt;--all&lt;/code&gt;, 显示全部的文件，包括以&lt;code&gt;.&lt;/code&gt;开头的隐藏文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;: 长列表的形式呈现文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;：以文档修改时间排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt;：列出人能读懂的文件大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;：将目录也像问价那样列出来&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;使用范例&lt;br&gt;&lt;strong&gt;1)&lt;/strong&gt; 参数可以每个加&lt;code&gt;-&lt;/code&gt;列出，也可以组合，只用一个&lt;code&gt;-&lt;/code&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xxx@ubuntu:~$ ls -a -l -t -h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xxx@ubuntu:~$ ls -alth&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; 列出当前目录哪些文件名(比如以&lt;code&gt;d&lt;/code&gt;开头)的文件&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ls -l d*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;字符串替换&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ tmp=&quot;c:/windows/system32/dirviers&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $&amp;#123;tmp/windows/linux&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c:/linux/system32/dirviers&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;${变量/查找/替换值} 一个“/”表示替换第一个，”//”表示替换所有,当查找中出现了：”/”请加转义符”\/”表示。 &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $&amp;#123;tmp//\//*&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c:*windows*system32*dirviers&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将所有斜杠&lt;code&gt;/&lt;/code&gt;转换成&lt;code&gt;\&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ tmp=($&amp;#123;tmp//\//\\&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(py36) 2018211154@ubuntu:~/Datasets/yelp-dataset$ echo $tmp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c:\windows\system32\dirviers&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;移动某种类型的文件&lt;/p&gt;
&lt;p&gt;mv *.txt new_dir/&lt;/p&gt;
&lt;p&gt;按照一定条件输出某文件的某些行到另外的文件&lt;/p&gt;
&lt;p&gt; awk ‘NR==2{print $0 &amp;gt;&amp;gt; “tmp.txt”}’ py27_stars_count_1_to_100.txt &lt;/p&gt;
&lt;p&gt;单引号里面是指令，双引号表示字符串&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk &lt;span class=&quot;string&quot;&gt;&#39;NR1&amp;#123;print $0 &amp;gt;&amp;gt; &quot;temp_result.txt&quot;&amp;#125; FNR2&amp;#123;print $0 &amp;gt;&amp;gt; &quot;temp_result.txt&quot;&amp;#125;&#39;&lt;/span&gt; &amp;#123;1..5&amp;#125;.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.blankspace.cn/categories/Linux/"/>
    
      <category term="Shell" scheme="https://www.blankspace.cn/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="https://www.blankspace.cn/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）Kaggle机器学习入门教程笔记</title>
    <link href="https://www.blankspace.cn/2018/10/06/kaggle-learnm-ml-lv1/"/>
    <id>https://www.blankspace.cn/2018/10/06/kaggle-learnm-ml-lv1/</id>
    <published>2018-10-06T12:34:51.000Z</published>
    <updated>2018-10-08T01:24:59.966Z</updated>
    
    <content type="html"><![CDATA[<p>原教程，看<a href="https://www.kaggle.com/learn/machine-learning" target="_blank" rel="noopener">这里</a>。</p><p>课次：19。预计花费时长：4小时（实际我花了不止这么多时间）。</p><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原教程，看&lt;a href=&quot;https://www.kaggle.com/learn/machine-learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;课次：19。预计花费时长：4小时（实际我花了不止这么多时间）。&lt;/p&gt;
&lt;h2 id=&quot;Level-1&quot;&gt;&lt;a href=&quot;#Level-1&quot; class=&quot;headerlink&quot; title=&quot;Level 1&quot;&gt;&lt;/a&gt;Level 1&lt;/h2&gt;&lt;h2 id=&quot;Level-2&quot;&gt;&lt;a href=&quot;#Level-2&quot; class=&quot;headerlink&quot; title=&quot;Level 2&quot;&gt;&lt;/a&gt;Level 2&lt;/h2&gt;
    
    </summary>
    
      <category term="Data Science" scheme="https://www.blankspace.cn/categories/Data-Science/"/>
    
      <category term="Competition" scheme="https://www.blankspace.cn/categories/Data-Science/Competition/"/>
    
      <category term="Kaggle" scheme="https://www.blankspace.cn/categories/Data-Science/Competition/Kaggle/"/>
    
    
      <category term="Kaggle" scheme="https://www.blankspace.cn/tags/Kaggle/"/>
    
      <category term="Skit-learn" scheme="https://www.blankspace.cn/tags/Skit-learn/"/>
    
      <category term="Python" scheme="https://www.blankspace.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）向量/矩阵微分</title>
    <link href="https://www.blankspace.cn/2018/10/05/vector-matrix-derivatives/"/>
    <id>https://www.blankspace.cn/2018/10/05/vector-matrix-derivatives/</id>
    <published>2018-10-05T02:44:32.000Z</published>
    <updated>2018-10-05T15:21:46.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本文部分内容引用自James E. Gentle所著的《Matrix Algebra: Theory, Computations, and Applications in Statistics》。</p></blockquote><p>向量（Vector）和矩阵（Matrix）对于表达多变量数据很有用，特别是处理线性方程或者表达对象间的线性关系，使用向量和矩阵是很自然的表示。</p><h2 id="向量，矩阵概念和符号表示"><a href="#向量，矩阵概念和符号表示" class="headerlink" title="向量，矩阵概念和符号表示"></a>向量，矩阵概念和符号表示</h2><p>向量和矩阵有很多种不同的精确定义，但是我们通常认为<strong>向量</strong>就是排成直线的数组（或者说标量数组），而<strong>矩阵</strong>就是排成矩形的数组。</p><p>“通常没有特别说明，<strong>标量（Scalar）</strong>认为是实数（Real Number，注：实数是有理数 <strong>rational number</strong>  和无理数 <strong>irrational number</strong> 的总称，也就是能够在一条直线上标注出来的连续的数值。实数是和<a href="https://en.wikipedia.org/wiki/Imaginary_number" target="_blank" rel="noopener">虚数 Imaginary Number </a>相对的概念，“虚实结合”共同构成了<a href="https://en.wikipedia.org/wiki/Complex_number" target="_blank" rel="noopener">复数 Complex Number</a>。)。我们将实数组成的集合以及实数域记作$\mathbb{R}$（域field，包含集合以及操作数operator）。则我们将$\mathbb{R}$之中的元素称之为标量”</p><p>有时候，也可以从几何的角度看待向量和矩阵，在平冈和幸所著的《プログラミングのための線形代数 （用于编程的线性代数）》（卢晓南中译本叫做《程序员的数学：线性代数》）就反复强调了<strong>矩阵就是几何变换</strong>的概念。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>对于正整数n，一个向量就是一个n元组、有序集合或n个称之为标量的元素组成的数组。元素的数量称之为order（阶），有时称之为向量的“长度（length）”。</p><p>一个n-vector可以视作是n维空间中的一个点，而在这种情况下，长度代表的就是原点到该向量所表示点的欧氏距离：也就是元素平方和开平方根。</p><p>一般约定的表示向量使用小写英文字母表示，相同的字母带下标表示想两种的某个元素。向量中的第一个元素记为第1个元素，最后一个元素记为第n个元素（计算机科学中通常将第一个元素记为第0号，最后一个元素记为第n-1号。张学工老师的《模式识别》中是按照这种方式表示的，数学中偏好从1开始的记法）。</p><p>一个n-vector写作：</p><script type="math/tex; mode=display">x=\begin{bmatrix}x_1 \\x_2 \\\vdots \\x_n\end{bmatrix} \tag{1}</script><p>或者：</p><script type="math/tex; mode=display">x=\begin{bmatrix}x_1, x_2, \cdots, x_n \end{bmatrix} \tag{2}</script><p>通常向量被视为一列，所以第一种表示法更为自然，但是不太方便书写，所以会写成行向量转置的形式。</p><p>使用符号</p><script type="math/tex; mode=display">\mathbb{R^n}</script><p>记为所以n-vector组成的集合。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组是一堆元素组成的有结构的整体（collection），对应的有直线，矩形以及立方体等形状。数组的维数称为数组的秩（rank）。因此，向量是秩为1的数组，矩阵是秩为2的数组，对于标量，我们认为其实退化的秩为0的数组。数组的秩值得是数组的维数，这和矩阵的秩的概念不同，矩阵的秩表示矩阵中线性无关向量的最大数量值。</p><h3 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h3><p>矩阵是一个矩形的或者二维的数组。一个$n \times m$的矩阵表示有n行m列，若n==m，那么矩阵就是一个方阵。按照上面对于维数的定义，所有的矩阵都是2维的。但是到了矩阵这里，维的定义又不一样了，其代表了矩阵列的个数。</p><p>通常使用大写字母来表示矩阵，而为了表示矩阵中的元素，通常表示为对应的小写字母，加上两个下标，第一个下标表示行号，第二个下标表示列的位号。使用符号$a_{<em>j}$表示矩阵$A$的第$j$列，符号$a_{i</em>}$表示矩阵$A$的第$i$行。</p><p>$n\times m$的矩阵可以写作：</p><script type="math/tex; mode=display">A=\begin{bmatrix}a_{11}&\cdots&a_{1m} \\\vdots&\vdots&\vdots \\a_{n1}&\cdots&a_{nm} \\\end{bmatrix} \tag{3}</script><p>使用符号$A_{n\times m}$表示一个矩阵是$n\times m$列的。使用符号：</p><script type="math/tex; mode=display">\mathbb{R^{n\times m}}</script><p>记为所有$n\times m$标量矩阵组成的集合。使用符号$(A)_{ij}$指明矩阵第$i$行第$j$列的元素，$(A)_{ij}=a_{ij}$。</p><p>对于向量还有矩阵的微分和积分，是对在标量变量上相应操作的扩展。~PS:然鹅很悲催的是我记忆里无论是微积分还是线性代数，好像都没有讲对于向量还有矩阵的微分和积分，也许这就是我是个学渣的原因吧😂~。其中需要注意三个关键点：</p><ul><li>操作的变量（variables），即对谁进行微分（之后可能会介绍向量/矩阵的积分，到时候就是操作就是积分）</li><li>操作数（operand），即要进行微分的函数</li><li>操作的结果，即微分的结果。</li></ul><h2 id="微分概念和符号表示"><a href="#微分概念和符号表示" class="headerlink" title="微分概念和符号表示"></a>微分概念和符号表示</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>根据导数的定义，一个函数的导数，是函数在变量发生很小一段变化时在该处函数变化率取极限。</p><p>现在变量$\Xi$是向量、矩阵对象，而函数$\Phi$也是对于关于向量、矩阵的函数。函数$\Phi$的变化，表示为：</p><script type="math/tex; mode=display">\delta\Phi = \Phi_{new}-\Phi_{old}</script><p>变量的变化：</p><script type="math/tex; mode=display">\delta\Xi= \Xi_{new}-\Xi_{old}</script><p>它们也都可以计算出来，比方说使用<a href="https://en.wikipedia.org/wiki/Norm" target="_blank" rel="noopener">范式</a>（就将向量、矩阵转换成标量）来衡量值的变化。</p><p>但是为了计算对于向量、矩阵的导数，不能直接来除以$\delta\Xi$，因为我们没有定义除以向量、矩阵这样的运算。所以我们将其转换成一个可解的问题，即除以范数来解决，于是就可以这样定义上述函数的变化：</p><script type="math/tex; mode=display">\lim_{\Vert\delta\Xi\Vert\to0}{\frac{\Phi(\Xi+\delta\Xi) - \Phi(\Xi)}{\Vert\delta\Xi\Vert}} \tag{4}</script><p>由于无论是向量还是矩阵都定义了和标量的乘法运算，所以上式可以转换为：</p><script type="math/tex; mode=display">\lim_{t\to0}{\frac{\Phi(\Xi+t\Upsilon) - \Phi(\Xi)}{t}} \tag{5}</script><p>其中$t$是一个标量，$\Upsilon$是要被加到$\Xi$上（也就是引起改变的）的向量或者矩阵。因此，有上式要求得向量、矩阵的导数（求出了微分也就求出了），<strong>$\Phi$的类型可能是标量，向量或矩阵，同样的对于$\Xi$和$\Upsilon$也有可能是标量，向量或矩阵，要分类分析这些情况</strong>。</p><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p>根据导数的定义，如果一个函数在某点的导数存在，那么必须满足，函数在该点是连续的才行。关于向量、矩阵的导数，其连续性如何判断呢？</p><p>以下几种情况均能保证关于向量或矩阵的函数的连续性：</p><ul><li>向量或矩阵每个元素都是连续的</li><li>（正如标量的和还有积是连续的）向量、矩阵的和以及积也是连续的</li><li>连续函数的连续函数是连续的</li><li>矩阵的行列式是连续函数</li><li>矩阵的逆是连续函数</li></ul><h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><ul><li>$\partial/\partial x$或$\partial/\partial x^T$：对于$x$的偏导</li><li>$\partial/\partial x_i$：对于标量$x_i$的偏导</li></ul><h2 id="微分类型和计算"><a href="#微分类型和计算" class="headerlink" title="微分类型和计算"></a>微分类型和计算</h2><blockquote><p>注：由上面的概念可知，无论向量还是矩阵，其中的元素都是标量，至于导数的计算，总的思路就是将其转化为已经定义和可解的对于标量的导数。</p></blockquote><h3 id="关于标量变量的微分"><a href="#关于标量变量的微分" class="headerlink" title="关于标量变量的微分"></a>关于标量变量的微分</h3><h4 id="向量关于标量的导数"><a href="#向量关于标量的导数" class="headerlink" title="向量关于标量的导数"></a>向量关于标量的导数</h4><script type="math/tex; mode=display">\frac{\partial{y}}{\partial{x}}=\left(\frac{\partial{y_1}}{\partial{x}}, \frac{\partial{y_2}}{\partial{x}}, \dots,  \frac{\partial{y_n}}{\partial{x}} \right)^T \tag{6}</script><p>其中$y(x)=(y_1(x), y_2(x), \dots, y_n(x))^T$。向量关于标量的二阶导还有高阶导是同样是一个向量，其中每个元素是对应元素关于标量的二阶导还有高阶导。</p><p>这是怎么得来的呢？</p><p>“万事开头难”，虽然有的人能够一眼看出来，但是动手验证一遍还是蛮好的。先从具体计算$\partial y_5/\partial x$，由于$y_5(x)$是关于标量$x$的函数，所以直接计算出$\partial y_5/\partial x$就好了。而$y$是关于$x$函数组成的向量，因此同理，$\partial y_i/\partial x$都能直接求出来，因此就有式(6)的结论。</p><p>之后的情况总体也是采用这种“把草稿纸捡起来”的推导过程，从而最后完成对于对向量，矩阵的求导。</p><h4 id="矩阵关于标量的导数"><a href="#矩阵关于标量的导数" class="headerlink" title="矩阵关于标量的导数"></a>矩阵关于标量的导数</h4><p>（待完善…）</p><h4 id="函数关于标量的导数"><a href="#函数关于标量的导数" class="headerlink" title="函数关于标量的导数"></a>函数关于标量的导数</h4><h4 id="关于标量的高阶导"><a href="#关于标量的高阶导" class="headerlink" title="关于标量的高阶导"></a>关于标量的高阶导</h4><h3 id="关于向量变量的微分"><a href="#关于向量变量的微分" class="headerlink" title="关于向量变量的微分"></a>关于向量变量的微分</h3><h3 id="关于矩阵变量的微分"><a href="#关于矩阵变量的微分" class="headerlink" title="关于矩阵变量的微分"></a>关于矩阵变量的微分</h3><p>（待完善…）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：本文部分内容引用自James E. Gentle所著的《Matrix Algebra: Theory, Computations, and Applications in Statistics》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;向
      
    
    </summary>
    
      <category term="Math" scheme="https://www.blankspace.cn/categories/Math/"/>
    
      <category term="Algebra" scheme="https://www.blankspace.cn/categories/Math/Algebra/"/>
    
      <category term="Matrix Algebra" scheme="https://www.blankspace.cn/categories/Math/Algebra/Matrix-Algebra/"/>
    
    
      <category term="Vector" scheme="https://www.blankspace.cn/tags/Vector/"/>
    
      <category term="Matrix" scheme="https://www.blankspace.cn/tags/Matrix/"/>
    
      <category term="Derivative" scheme="https://www.blankspace.cn/tags/Derivative/"/>
    
  </entry>
  
  <entry>
    <title>解决SPX截图时屏幕无故放大的问题</title>
    <link href="https://www.blankspace.cn/2018/10/03/solve-screen-capture/"/>
    <id>https://www.blankspace.cn/2018/10/03/solve-screen-capture/</id>
    <published>2018-10-03T05:53:21.000Z</published>
    <updated>2018-10-03T08:17:57.835Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="http://www.instant-screen-capture.com/" target="_blank" rel="noopener">SPX</a>是个非常好用的截图工具，特色就是其撕边功能，虽然有时候只是看上去很酷而已，但是很有趣。</p><p><img src="/2018/10/03/solve-screen-capture/SPX.png" alt="SPX截图效果"></p><p>　　此外其也提供了模糊，注释，标号，箭头，保存到文件，发送到打印机等功能。</p><p><img src="/2018/10/03/solve-screen-capture/SPX-editor.png" alt="SPX-editor"></p><p>　　在使用的过程中我发现其存在的几个BUG，第一个，在Windows 10上当我的屏幕分辨率调成最高，同时文字缩放调成推荐的125%，截图的时候程序就会莫名放大，导致只能截取屏幕一部分区域；第二个，中文注释存在问题，设置字符集为GB2312能够显示中文，但是注释后面总会跟奇怪的字符，有的时候是<code>a</code>有的时候是<code>\1</code>，而西文字符不存在这个问题。</p><p>　　对于第一个问题，一种解决方案就是文字缩放调成100%，这样就不会莫名放大了，但是电脑的图标还有文字就会显得很小，这样对视力不好。</p><p>　　后来经过摸索，应该是程序兼容性导致的，关于Windows程序兼容性的调整，看<a href="https://support.microsoft.com/zh-cn/help/15078/windows-make-older-programs-compatible" target="_blank" rel="noopener">使旧版程序与此版本的 Windows 兼容</a>，于是就将程序的属性中的兼容性改成Windows7就一切正常了（找到应用程序图标，鼠标右键属性）。</p><p>　　对于第二个问题，应该就是软件自身的BUG了，只能尽量使用英文注释了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;http://www.instant-screen-capture.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SPX&lt;/a&gt;是个非常好用的截图工具，特色就是其撕边功能，虽然有时候只是看上去很酷而已，但是很有趣。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Misc" scheme="https://www.blankspace.cn/categories/Misc/"/>
    
      <category term="Bugs" scheme="https://www.blankspace.cn/categories/Misc/Bugs/"/>
    
      <category term="OS" scheme="https://www.blankspace.cn/categories/Misc/Bugs/OS/"/>
    
    
      <category term="Windows" scheme="https://www.blankspace.cn/tags/Windows/"/>
    
      <category term="SPX" scheme="https://www.blankspace.cn/tags/SPX/"/>
    
  </entry>
  
  <entry>
    <title>Git快速参考</title>
    <link href="https://www.blankspace.cn/2018/10/02/git-quick-reference/"/>
    <id>https://www.blankspace.cn/2018/10/02/git-quick-reference/</id>
    <published>2018-10-02T12:00:53.000Z</published>
    <updated>2018-10-03T12:02:19.474Z</updated>
    
    <content type="html"><![CDATA[<p>Git进行版本控制，管理的是修改而非文件。<br>分清楚工作区，版本库，暂存区(stage)就能很好地理解其工作原理。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>工作区（Working Directory）：顾名思义是工作的地方，对文件的创建，修改，添加，删除等都会对其造成影响。比方说我创建的一个项目工程就是一个工作区。<br>版本库(Repository)：工作区中有一个隐藏的目录.git，不算工作区而是Git版本库。<br>Git版本库最终的就是stage（或者叫index）的暂存区，还有Git默认创建的master分支，以及指向master分支的HEAD指针。<br>文件的增删变更直接作用在工作区，第一步，变更后add，就添加到了版本库的暂存区。<br>第二步，git commit提交更改，就是将暂存区的所有内容提交到当前分支。<br>简单的理解就是，需要提交的文件修改都放在暂存区，然后一次性提交暂存区中的内容到到当前分支。</p><h2 id="文件修改和“时光穿梭”"><a href="#文件修改和“时光穿梭”" class="headerlink" title="文件修改和“时光穿梭”"></a>文件修改和“时光穿梭”</h2><ul><li>场景1：当修改了工作区的文件内容，觉得不合适，想直接丢弃工作区的修改，使用命令：<code>git checkout -- filenname</code></li><li>场景2：当修改了工作区的文件内容，觉得不合适，但是已经通过<code>git add</code>添加修改到了暂存区，想直接丢弃工作区的修改，分两步，第一步，使用命令<code>git reset HEAD filename</code>，就回到了场景1；第二步按照场景1来操作。</li><li>场景3：已经通过<code>git commit</code>提交了不合适的修改到版本库中，想要撤销本次提交，就执行版本退回命令，<code>git reset --hard commid_id</code>进行时光穿梭。穿梭前可以使用<code>git log</code>查看历史版本；当还需要重返未来的时候，使用<code>git reflog</code>查看历史命令。</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>使用<code>rm filename</code>来在工作区删除文件，现在工作区和版本库就不一致了。</p><ul><li>场景1：确认删除该文件，使用<code>git rm filename</code>命令，然后<code>git commit</code></li><li>场景2：属于误删操作，但是还没有提交到版本库，使用命令<code>git checkout -- filename</code>，使用版本库中的版本替换到工作区的版本。</li><li>场景3：已经提交到版本库，发现属于误删操作，执行版本回退来时光穿梭。</li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul><li>创建和切换分支：<code>git checkout -b branch_name</code>.相当于两句指令：<code>git branch branch_name</code>, 随后<code>git checkout branch_name</code></li></ul><p>ps: 关于Vim重命名文件，在退出之前输入<code>:sav new_file_name</code>即可，会保存一个相同内容的副本，而不是在当前修改文件中修改，要想这样需要安装特定的插件。</p><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch &lt;branch_name&gt;</code></li><li>切换到分支：<code>git checkout &lt;branch_name&gt;</code></li><li>创建加切换：<code>git checkout -b &lt;branch_name&gt;</code></li><li>合并到当前：<code>git merge &lt;branch_name&gt;</code></li><li>删除分支：<code>git branch -d &lt;branch_name&gt;</code></li></ul><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>新建分支在上面修改后，add, commit，然后切换到要汇入的分支上，假如此时在当前分支上也做了修改，执行<code>git merge &lt;branch_to_be_merged&gt;</code>时发现无法合并，使用<code>git status</code>查看冲突位置，然后修改冲突（就是文件中标注的位置，通常就是同一行内容不一致导致的）,修改完毕后重新add，commit，以及merge就行了。<br>可以使用<code>git log --graph &lt;--abbrev-comit&gt; 查看分支合并情况图</code>。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常合并分支使用的都是<code>Fast forward</code>模式，在合并的时候加上<code>--no-ff</code>参数就可以采用普通模式合并，历史记录中会有分支的信息，而<code>Fast forward</code>在合并后删除分支日志历史中就没有关于此分支的记录，也就看不出来曾经做过合并。</p><h3 id="保存和恢复现场"><a href="#保存和恢复现场" class="headerlink" title="保存和恢复现场"></a>保存和恢复现场</h3><p>场景：当手头正在多某项工作，突然接到任务需要马上处理，手头的工作不得不停下，但是还没有完善到能够提交的程度。该怎么办？<br>相当于打断点，保存现场，使用<code>git stach</code>保存当前的工作。然后去处理临时或者紧急的任务（比如说修复某个bug）。当临时或者紧急任务处理完毕后，返回来恢复现场继续原来的工作。<br>恢复现场使用,<code>git stash list</code>查看有哪些存档，然后使用<code>git stash apply &lt;stash@{xxx}&gt;</code>来恢复，参数是可选的用于多次stash之后选择要恢复的那个。这种方式恢复后stash的内容不删除，需要输入<code>git stash drop</code>来删除。<br>另一种方式能够恢复的同时删除stash，即使用<code>git stash pop</code>。</p><h3 id="删除未合并过的分支"><a href="#删除未合并过的分支" class="headerlink" title="删除未合并过的分支"></a>删除未合并过的分支</h3><p>场景：导师给了个新需求要做，做完了却悲催地听说不需要了，现在要删除这个分支。<code>git brach -d &lt;feature&gt;</code>，会提示<code>The branch &#39;&lt;feature&gt;&#39; is note fully merged. If you are sure you want to delete it , run&#39;git branch -D &lt;feature&gt;&#39;</code>。</p><p>所以<code>git branch -D &lt;branch_name&gt;</code>就是强制删除未曾合并过的分支的命令。</p><h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><ul><li>场景1：在本地创建了一个分支，但是远程没有，commit之后希望push到远程比方说Github上，但是不是master分支，而是一个目前还没有创建的分支上。使用<code>git push -u origin &lt;local_branch_name&gt;</code>,这样就在远程创建了和<code>local_branch_name</code>同名分支。</li><li><p>场景2：远端已经存在和本地同名或者不同名的分支，希望这时将本地的分支推到远端上，<code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></p></li><li><p>场景3：当有多人同时提交到一个分支，自己的提交和他人的有冲突，这时按照提交的提示来做，一般会提示<code>git pull ...</code>，将远程的提交pul下来。pull下来后再次提交，若发现push有冲突，则需要手动解决冲突，解决方法和上文的冲突解决一致。解决后再进行push即可。</p></li><li>场景4：远程已经存在某个分支，想在本地创建一个分支和远程的分支对应起来。使用<code>git checkout -b local_branch_name origin/remote_branch_name</code></li><li>场景5：远程已经存在某个分支，本地同时存在某个分支，现在要把两个关联起来，使用<code>git branch --set-upstream-to=origin/remote_branch_name local_branch_name</code>,制定本地分支和远程分支的关联。这样就能解决某些时候pull失败的问题，比如<code>no tracking information</code>。</li></ul><h2 id="rebase整理push历史"><a href="#rebase整理push历史" class="headerlink" title="rebase整理push历史"></a>rebase整理push历史</h2><ul><li>场景：本地版本历史过多，有的commit并没有push到远程，所以再查看历史的时候希望只查看push过的提交，使用<code>git rebase</code>命令实现。</li></ul><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="为commit打上标签"><a href="#为commit打上标签" class="headerlink" title="为commit打上标签"></a>为commit打上标签</h3><ul><li><p>场景1：某个工作已经进行了多次的编辑和提交。过了一阵子，导师或者其他人说，请把之前的某次提交打包一下。这时选择查找<code>commit_id</code>显得就不是很方便。<code>tag</code>就相当于是对于commit的起的别名，使用<code>git tag &lt;tag_name&gt;</code>默认为最近的一次提交打上标签，在产看log的时候，就会出现相应的标签提示。使用<code>git show tag_name</code>来查看<code>tag_name</code>对应的那次提交。</p></li><li><p>场景2：之前的提交忘记打标签，现在需要对历史中某个版本打上标签。使用<code>git tag tag_name commit_id</code>。使用<code>git tag</code>查看所有标签。</p></li><li><p>场景3：创建某个标签的同时，还提供一些说明信息。使用<code>git tag -a tag_name -m &quot;balala enengy... commit_id</code>。使用<code>git show tag_name</code>就能查看到相应说明文字。</p></li></ul><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><ul><li>场景1，打错了，在本地删除：<code>git tag -d tag_name</code></li><li>场景2，推送某次提交的标签到远程：<code>git push origin tag_name</code></li><li>场景3，推送全部尚未推送到远程的标签：<code>git push origin --tags</code></li><li>场景4，删除远程的标签：先要删除本地的要删除的标签。然后执行，<code>git push origin :refs/tags/tag_name</code>，然后去远程查看标签是否被删除。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>除了配置<code>user.name</code>, <code>user.email</code>之外还可以配置一些东西。</p><ul><li>场景，命令行工作颜色单调：配置显示ui, <code>git config --global color.ui true</code>，使文件名也被不同的颜色标注。（我使用git bash本身就是有颜色的）。</li></ul><h2 id="设置忽略规则"><a href="#设置忽略规则" class="headerlink" title="设置忽略规则"></a>设置忽略规则</h2><p>这个功能非常有必要，特别是在一些项目中有比较大或者涉及敏感信息的文件时（比如密码，很大很大的数据集等）。编写<code>.gitignore</code>文件来屏蔽某些类型的文件。文件每行表示一个屏蔽规则，一个规则可以屏蔽某个具体的文件或者某一类或几类文件的提交。可以使用通配符来编写规则，<code>#</code>作为注释。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要忽略提交什么文件</span></span><br><span class="line">file_name</span><br><span class="line">*.dat</span><br><span class="line">*.py[cod]</span><br><span class="line">db.ini</span><br></pre></td></tr></table></figure></p><ul><li>当发现某个在屏蔽规则中文件恰好必须要提交上去，使用<code>git add -f file_name.file_type</code></li><li>使用<code>git check-ignore</code>来检查屏蔽规则</li></ul><h2 id="配置命令别名"><a href="#配置命令别名" class="headerlink" title="配置命令别名"></a>配置命令别名</h2><ul><li>通常使用缩写来给某个长的命令或者组合当做别名，来提高生产效率。使用<code>git config --global alias.s_name &#39;long_command_name&#39;</code>,比如：<code>git config --global alias.br branch</code>，就可以使用<code>git br</code>代替<code>git branch</code>操作了。</li></ul><p>例如：</p><blockquote><p>git config —global alias.lg “log —color —graph —pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ —abbrev-commit”</p></blockquote><ul><li>删除某个别名：别名放在隐藏文件<code>.git/congif</code>的<code>[alias]</code>后，删除别名直接把对应的行删除即可。也可以在用户主目录下的隐藏文件<code>.gitconfig</code>中也存放了当前用户的Git配置，可以删除文件重新配置命令。</li></ul><h2 id="架设Git服务器"><a href="#架设Git服务器" class="headerlink" title="架设Git服务器"></a>架设Git服务器</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">参考1</a><br><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server" target="_blank" rel="noopener">参考2</a></p><p>总的来说基于Linux系统，在裸Git仓库上配置协议，就能搭建成功。有相关工具来完善和方便管理,<code>Gitosis</code>管理公钥，使用<code>Gitolite</code>进行权限管理。</p><p>当然还有<code>GitLab</code>方便搭建私有Git仓库，进行团队管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git进行版本控制，管理的是修改而非文件。&lt;br&gt;分清楚工作区，版本库，暂存区(stage)就能很好地理解其工作原理。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h
      
    
    </summary>
    
      <category term="Version Control" scheme="https://www.blankspace.cn/categories/Version-Control/"/>
    
      <category term="Git" scheme="https://www.blankspace.cn/categories/Version-Control/Git/"/>
    
    
      <category term="Git" scheme="https://www.blankspace.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>聚类分析</title>
    <link href="https://www.blankspace.cn/2018/09/27/data-mining-ch01-s02-01/"/>
    <id>https://www.blankspace.cn/2018/09/27/data-mining-ch01-s02-01/</id>
    <published>2018-09-27T00:59:31.000Z</published>
    <updated>2018-09-27T09:00:47.524Z</updated>
    
    <content type="html"><![CDATA[<p>　　学习不应当机械重复和记忆，要善于将现有的知识和理论用自己的方式进行理解和转化，就是用自己的话说出来。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>　　人类（但不仅仅是人类）通常很擅长也很喜欢聚类。在对世界的观察和理解中，要将特定的对象指派到特定的组中，“物以类聚，人以群分”，我感觉其实也就是分类啦，只不过为了和原始数据提供标记的分类任务区分开来，没有提供标记的任务就是聚类啦，组也不叫组了，就叫做簇cluster，聚类就叫做clustering。聚类不是终点而是起点，为很多工作做下铺垫，比如说数据分析。</p><p>　　聚类有为了理解的，也有为了建立高层的抽象的，前一种比如生物学中的层次分类，界门纲目科属种（kingdom，phylum，class，order，family，genus，species）；信息检索中搜索结果返回若干簇；心理学和医学研究等。后一种如某些算法为了减小分析复杂度，对于数据集的簇使用而不是整个数据集，能够得到和使用所有数据相媲美的结果；还有如压缩，如向量量化，将数据对象使用所在簇的序索引来表示；发现最近邻等。</p><h3 id="簇的定义"><a href="#簇的定义" class="headerlink" title="簇的定义"></a>簇的定义</h3><p>　　可以说是一个个的分组，组内之间相互之间是相似的（相关的），而不同组之间的对象是不同的（不想关的）。组内的相似性（同质性）越大越好，组间差别越大越好。分组依赖于数据的特性以及期望的结果，所以实际上是需求驱动的。</p><h3 id="聚类类型"><a href="#聚类类型" class="headerlink" title="聚类类型"></a>聚类类型</h3><ul><li>划分 VS 层次：划分聚类（partitional clustering）使不同簇之间不能重叠，每个对象恰在一个簇中。层次聚类（hierarchical clustering），按层次嵌套组成一棵树，除叶子节点之外，所有的簇都是其子簇的并。</li><li>互斥，重叠和模糊：重叠（overlapping）/非互斥（non-exclusive）聚类反映一个对象属于多个类。模糊聚类（fuzzy clustering）将属于某个簇给定一个权重系数，介于0和1之间，0代表绝对不属于，1代表确定一定加肯定，每个兑现的权重之和等于1。同理的概率聚类也是计算一个对象属于每个簇的概率，所有概率之和等于1。实践中通常将最大系数，最高概率的对象指派到对应的类上，从而转换成为互斥聚类。</li><li>完全 VS 部分：完全聚类将每个对象指派到一个簇。而部分聚类选取感兴趣的点，而忽略一些噪声或者背景，离群点等，“找主要矛盾”。</li></ul><h3 id="簇的分类"><a href="#簇的分类" class="headerlink" title="簇的分类"></a>簇的分类</h3><ul><li>明显分离的：簇与簇一看就有明显的分界</li><li>基于原型：原型通常是质心/中心点或者其他最具代表性的点，而簇中每个对象到原型的距离（相似度）都要到其他簇的距离更近（更相似）。</li><li>基于图的：图就有边和点，点通常是对象，边就是对象之间的联系，簇可以定义成联通分量，也就是相互联通单数不和分量外的对象联通。还有基于邻近的簇（contiguity-based cluster），也就是两点点只有距离大于一定的阈值，才算作它们是联通的。此外还有比如基于团（clique）的基于图的其他聚类，团也就是集合之间所有的点完全连接。</li><li>基于密度：可以和噪声区分</li><li>概念簇：通常是很具体的簇中对象的共同性质</li><li>…</li></ul><h3 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h3><ul><li>K均值：其实基于原型的，划分的，聚类技术，将数据聚成你所指定的K个簇</li><li>凝聚的层次聚类：基于层次的聚类：开始每个点就是一个簇，然后，重复合并最相靠近的簇，直到产生包含所有点的簇，就形成了整个层次聚类的树。其中某些技术可能是基于图的聚类。</li><li>DBSCAN：产生于划分聚类的基于密度的聚类算法，簇的个数由算法自动确定，低密度的区域中的点被视为噪声而忽略，即DBSCAN不产生完全聚类。</li></ul><h2 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h2><h3 id="基本K均值"><a href="#基本K均值" class="headerlink" title="基本K均值"></a>基本K均值</h3><p>使用伪代码的形式进行描述：</p><div class="table-container"><table><thead><tr><th>算法：基本K均值算法</th></tr></thead><tbody><tr><td>1.选择(一般是随机选)K个点作为初始质心<br>2.repeat<br>3.　对每个点求其到K个质心的距离，离谁最近则指派到哪个质心，从而所有点最终形成K个簇<br>4.　对每个簇重新计算质心<br>5.until  每个簇的质心不在发生变化</td></tr></tbody></table></div><h3 id="K均值：附加问题"><a href="#K均值：附加问题" class="headerlink" title="K均值：附加问题"></a>K均值：附加问题</h3><p>我的问题：</p><ol><li>$\color{\red}{为啥收敛？}$</li></ol><p>　　首先预热一下：</p><p>　　给定m个点组成的点集$X=\{x_1, x_2, \dots, x_m\}$，满足$C, x_i \in \mathbb{R^n}$：</p><script type="math/tex; mode=display">E(X)=\operatorname*{argmin}_{x_i \in X} \Vert x_i - C \Vert_2</script><p>　　则C为X的几何中心。比方说二维平面上的三个点，连接在一起组成一个三角形，则到三个点欧氏距离最短的点是 它们的重心，即$C=( (x_1+x_2+x_3)/3, (y_1, y_2, y_3)/3 )$。</p><p>　　直观上来讲是这样的，但是如何证明呢？“实际上很困难，其没有确定的表达式。但是可以采用迭代的过程每次求一个近似值来逼近”<a href="https://en.wikipedia.org/wiki/Geometric_median" target="_blank" rel="noopener">[1]</a>，而且能够确定一定能够找到其全局最优解，而不会陷入到局部最优解中，原因就在于其实一个凸函数，为什么呢？原因是“每个样本点到到特定点的距离是一个凸函数，凸函数相加也是凸函数”。具体的算法有<a href="https://en.wikipedia.org/wiki/Geometric_median#Computation" target="_blank" rel="noopener"><strong>Weiszfeld法</strong> </a>：</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b3fb215363358f12687100710caff0e86cd9d26b" alt="Weiszfeld算法"></p><p>当其估计点落在给定点上时可能无法收敛，可以通过修改来使其收敛。</p><p>　　为什么k-means是收敛的，本质原因在于<strong>其属于EM算法的范畴，而EM算法是收敛的</strong>。</p><p>　　什么是EM算法，全称叫做Expectation Maximum，也就是期望最大，属于高斯混合模型（混合高斯模型）中讲到的内容。</p><p>之所以使用混合高斯模型，原因就在于聚类划分太“一刀切（hard）”，也就是说是“hard assignment”，然而现实情况存在一些“灰色地带”。由上面几何中心的推导可以得知，使用k均值算法，形成的簇都是基于中心的簇，</p><p>所以就要引入概率来衡量采样所归属的簇。</p><h3 id="二分K均值"><a href="#二分K均值" class="headerlink" title="二分K均值"></a>二分K均值</h3><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　学习不应当机械重复和记忆，要善于将现有的知识和理论用自己的方式进行理解和转化，就是用自己的话说出来。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;　　人类（但不仅仅是人类）通常很擅长也很喜欢聚类。在对世界的观察和理解中，要将特定的对象指派到特定的组中，“物以类聚，人以群分”，我感觉其实也就是分类啦，只不过为了和原始数据提供标记的分类任务区分开来，没有提供标记的任务就是聚类啦，组也不叫组了，就叫做簇cluster，聚类就叫做clustering。聚类不是终点而是起点，为很多工作做下铺垫，比如说数据分析。&lt;/p&gt;
&lt;p&gt;　　聚类有为了理解的，也有为了建立高层的抽象的，前一种比如生物学中的层次分类，界门纲目科属种（kingdom，phylum，class，order，family，genus，species）；信息检索中搜索结果返回若干簇；心理学和医学研究等。后一种如某些算法为了减小分析复杂度，对于数据集的簇使用而不是整个数据集，能够得到和使用所有数据相媲美的结果；还有如压缩，如向量量化，将数据对象使用所在簇的序索引来表示；发现最近邻等。&lt;/p&gt;
&lt;h3 id=&quot;簇的定义&quot;&gt;&lt;a href=&quot;#簇的定义&quot; class=&quot;headerlink&quot; title=&quot;簇的定义&quot;&gt;&lt;/a&gt;簇的定义&lt;/h3&gt;&lt;p&gt;　　可以说是一个个的分组，组内之间相互之间是相似的（相关的），而不同组之间的对象是不同的（不想关的）。组内的相似性（同质性）越大越好，组间差别越大越好。分组依赖于数据的特性以及期望的结果，所以实际上是需求驱动的。&lt;/p&gt;
&lt;h3 id=&quot;聚类类型&quot;&gt;&lt;a href=&quot;#聚类类型&quot; class=&quot;headerlink&quot; title=&quot;聚类类型&quot;&gt;&lt;/a&gt;聚类类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;划分 VS 层次：划分聚类（partitional clustering）使不同簇之间不能重叠，每个对象恰在一个簇中。层次聚类（hierarchical clustering），按层次嵌套组成一棵树，除叶子节点之外，所有的簇都是其子簇的并。&lt;/li&gt;
&lt;li&gt;互斥，重叠和模糊：重叠（overlapping）/非互斥（non-exclusive）聚类反映一个对象属于多个类。模糊聚类（fuzzy clustering）将属于某个簇给定一个权重系数，介于0和1之间，0代表绝对不属于，1代表确定一定加肯定，每个兑现的权重之和等于1。同理的概率聚类也是计算一个对象属于每个簇的概率，所有概率之和等于1。实践中通常将最大系数，最高概率的对象指派到对应的类上，从而转换成为互斥聚类。&lt;/li&gt;
&lt;li&gt;完全 VS 部分：完全聚类将每个对象指派到一个簇。而部分聚类选取感兴趣的点，而忽略一些噪声或者背景，离群点等，“找主要矛盾”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;簇的分类&quot;&gt;&lt;a href=&quot;#簇的分类&quot; class=&quot;headerlink&quot; title=&quot;簇的分类&quot;&gt;&lt;/a&gt;簇的分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;明显分离的：簇与簇一看就有明显的分界&lt;/li&gt;
&lt;li&gt;基于原型：原型通常是质心/中心点或者其他最具代表性的点，而簇中每个对象到原型的距离（相似度）都要到其他簇的距离更近（更相似）。&lt;/li&gt;
&lt;li&gt;基于图的：图就有边和点，点通常是对象，边就是对象之间的联系，簇可以定义成联通分量，也就是相互联通单数不和分量外的对象联通。还有基于邻近的簇（contiguity-based cluster），也就是两点点只有距离大于一定的阈值，才算作它们是联通的。此外还有比如基于团（clique）的基于图的其他聚类，团也就是集合之间所有的点完全连接。&lt;/li&gt;
&lt;li&gt;基于密度：可以和噪声区分&lt;/li&gt;
&lt;li&gt;概念簇：通常是很具体的簇中对象的共同性质&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;学习路径&quot;&gt;&lt;a href=&quot;#学习路径&quot; class=&quot;headerlink&quot; title=&quot;学习路径&quot;&gt;&lt;/a&gt;学习路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;K均值：其实基于原型的，划分的，聚类技术，将数据聚成你所指定的K个簇&lt;/li&gt;
&lt;li&gt;凝聚的层次聚类：基于层次的聚类：开始每个点就是一个簇，然后，重复合并最相靠近的簇，直到产生包含所有点的簇，就形成了整个层次聚类的树。其中某些技术可能是基于图的聚类。&lt;/li&gt;
&lt;li&gt;DBSCAN：产生于划分聚类的基于密度的聚类算法，簇的个数由算法自动确定，低密度的区域中的点被视为噪声而忽略，即DBSCAN不产生完全聚类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;K均值&quot;&gt;&lt;a href=&quot;#K均值&quot; class=&quot;headerlink&quot; title=&quot;K均值&quot;&gt;&lt;/a&gt;K均值&lt;/h2&gt;&lt;h3 id=&quot;基本K均值&quot;&gt;&lt;a href=&quot;#基本K均值&quot; class=&quot;headerlink&quot; title=&quot;基本K均值&quot;&gt;&lt;/a&gt;基本K均值&lt;/h3&gt;&lt;p&gt;使用伪代码的形式进行描述：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法：基本K均值算法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.选择(一般是随机选)K个点作为初始质心&lt;br&gt;2.repeat&lt;br&gt;3.　对每个点求其到K个质心的距离，离谁最近则指派到哪个质心，从而所有点最终形成K个簇&lt;br&gt;4.　对每个簇重新计算质心&lt;br&gt;5.until  每个簇的质心不在发生变化&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;K均值：附加问题&quot;&gt;&lt;a href=&quot;#K均值：附加问题&quot; class=&quot;headerlink&quot; title=&quot;K均值：附加问题&quot;&gt;&lt;/a&gt;K均值：附加问题&lt;/h3&gt;&lt;p&gt;我的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\color{\red}{为啥收敛？}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　首先预热一下：&lt;/p&gt;
&lt;p&gt;　　给定m个点组成的点集$X=\{x_1, x_2, \dots, x_m\}$，满足$C, x_i \in \mathbb{R^n}$：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
E(X)=\operatorname*{argmin}_{x_i \in X} \Vert x_i - C \Vert_2&lt;/script&gt;&lt;p&gt;　　则C为X的几何中心。比方说二维平面上的三个点，连接在一起组成一个三角形，则到三个点欧氏距离最短的点是 它们的重心，即$C=( (x_1+x_2+x_3)/3, (y_1, y_2, y_3)/3 )$。&lt;/p&gt;
&lt;p&gt;　　直观上来讲是这样的，但是如何证明呢？“实际上很困难，其没有确定的表达式。但是可以采用迭代的过程每次求一个近似值来逼近”&lt;a href=&quot;https://en.wikipedia.org/wiki/Geometric_median&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[1]&lt;/a&gt;，而且能够确定一定能够找到其全局最优解，而不会陷入到局部最优解中，原因就在于其实一个凸函数，为什么呢？原因是“每个样本点到到特定点的距离是一个凸函数，凸函数相加也是凸函数”。具体的算法有&lt;a href=&quot;https://en.wikipedia.org/wiki/Geometric_median#Computation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Weiszfeld法&lt;/strong&gt; &lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/b3fb215363358f12687100710caff0e86cd9d26b&quot; alt=&quot;Weiszfeld算法&quot;&gt;&lt;/p&gt;
&lt;p&gt;当其估计点落在给定点上时可能无法收敛，可以通过修改来使其收敛。&lt;/p&gt;
&lt;p&gt;　　为什么k-means是收敛的，本质原因在于&lt;strong&gt;其属于EM算法的范畴，而EM算法是收敛的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　什么是EM算法，全称叫做Expectation Maximum，也就是期望最大，属于高斯混合模型（混合高斯模型）中讲到的内容。&lt;/p&gt;
&lt;p&gt;之所以使用混合高斯模型，原因就在于聚类划分太“一刀切（hard）”，也就是说是“hard assignment”，然而现实情况存在一些“灰色地带”。由上面几何中心的推导可以得知，使用k均值算法，形成的簇都是基于中心的簇，&lt;/p&gt;
&lt;p&gt;所以就要引入概率来衡量采样所归属的簇。&lt;/p&gt;
&lt;h3 id=&quot;二分K均值&quot;&gt;&lt;a href=&quot;#二分K均值&quot; class=&quot;headerlink&quot; title=&quot;二分K均值&quot;&gt;&lt;/a&gt;二分K均值&lt;/h3&gt;
    
    </summary>
    
      <category term="Data Science" scheme="https://www.blankspace.cn/categories/Data-Science/"/>
    
      <category term="Data Mining" scheme="https://www.blankspace.cn/categories/Data-Science/Data-Mining/"/>
    
    
      <category term="Unsupervised Learning" scheme="https://www.blankspace.cn/tags/Unsupervised-Learning/"/>
    
      <category term="Clustering" scheme="https://www.blankspace.cn/tags/Clustering/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）LaTeX笔记</title>
    <link href="https://www.blankspace.cn/2018/09/23/latex-notes-01/"/>
    <id>https://www.blankspace.cn/2018/09/23/latex-notes-01/</id>
    <published>2018-09-23T02:14:46.000Z</published>
    <updated>2018-10-05T04:29:41.882Z</updated>
    
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;为什么要学习$\LaTeX$？原因很简单，“虽说气质为王，但往往也要看脸”，所以相当多的高质量的论文，书籍都会使用这种精确控制，外行看起来狂拽酷炫，不明嚼栗的排版工具，所以想发论文，这种排版神器的使用是圈子里必备且默认你会的技能。另外，我个人觉得Word十分好用，十分良心，所见即所得，功能十分强大。有人会褒一个贬一个，我觉得Word和$\LaTeX$都很好。现在有的期刊，会议也接受Word格式的论文，在有必要的时候学习也是极好的。</p><p>&#160; &#160; &#160; &#160;看过一些介绍$\LaTeX$ 的文章和书籍,很多作者写的很好，总体上也是从易到难，由浅入深。但是我看完之后，或者边看边学的过程中，总感觉缺了点什么，那就是这么多的规则，这么多符号，这么多宏包，什么时候才能用 $\LaTeX$ 写一篇像样的文章，什么时候才能写书，写论文呀！</p><p>&#160; &#160; &#160; &#160;我个人不想对$\LaTeX$ 做太深的研究，也不想向别人炫耀这种看似困难的工具的使用，只想发挥其该有的功用——更好地书写排版。所以在这里记下学习时的简单实用的笔记，尽快上手，同样也是边学习边练习边回顾，希望最终写出专业的论文以及其他优雅的出版物还有演示文稿，以掌握一个科研人员基本的素质。</p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="http://www.latexstudio.net/" target="_blank" rel="noopener">$\LaTeX$开源小屋</a>：很不错的中文$\LaTeX$社区，几乎应有尽有，资料很全</li><li><a href="https://cn.sharelatex.com/" target="_blank" rel="noopener">ShareLaTeX</a>：有丰富的模板，可以用来模仿</li><li>GitHub，简书，CSDN等，上面都已一些相关的模板，文章等</li><li><a href="https://tex.stackexchange.com/" target="_blank" rel="noopener">TeX StackExchange</a>还有Stack Overflow：遇到问题可以去上面查询</li></ul><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;ctex&#125;  %引入中文支持</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\LaTeX&#123;&#125; 你好  </span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/09/23/latex-notes-01/图1-latex最基础模板.png" alt="图1-latex最基础模板：\begin{environment\}...\end{environment} 中为内容，上面为导言区"></p><div class="bs-callout bs-callout-info"><h3 id="用法"><a href="#用法" class="headerlink" title="   用法"></a><i class="fa fa-info-circle"></i>   用法</h3><ul><li><code>\命令名称[备选参数]{（必选）参数}</code>：叫做命令。个人感觉类似于HTML中的<code>&lt;!DOCTYPE html&gt;</code>。例如，<code>\documentclass[a4paper]{ctexart}</code>，花括号中为必选参数，设置文档类型为<code>ctexart</code>。中括号里备选参数<code>a4paper</code>，将文档大小设置为A4纸大小。</li><li><code>\begin[...]{environment} ...\end{environment}</code>：叫做环境，用于控制<code>\begin[...]{environment}</code>和<code>\end{environment}</code>之间的内容。</li></ul></div><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;为什么要学习$\LaTeX$？原因很简单，“虽说气质为王，但往往也要看脸”，所以相当多的高质量的论文，书籍都会使用这种精确控制，外行看起来狂拽酷炫，不明嚼栗的排版工具，所以想发论文，这种排版神器的使用是圈子里必备且默认你会的技能。另外，我个人觉得Word十分好用，十分良心，所见即所得，功能十分强大。有人会褒一个贬一个，我觉得Word和$\LaTeX$都很好。现在有的期刊，会议也接受Word格式的论文，在有必要的时候学习也是极好的。&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看过一些介绍$\LaTeX$ 的文章和书籍,很多作者写的很好，总体上也是从易到难，由浅入深。但是我看完之后，或者边看边学的过程中，总感觉缺了点什么，那就是这么多的规则，这么多符号，这么多宏包，什么时候才能用 $\LaTeX$ 写一篇像样的文章，什么时候才能写书，写论文呀！&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;我个人不想对$\LaTeX$ 做太深的研究，也不想向别人炫耀这种看似困难的工具的使用，只想发挥其该有的功用——更好地书写排版。所以在这里记下学习时的简单实用的笔记，尽快上手，同样也是边学习边练习边回顾，希望最终写出专业的论文以及其他优雅的出版物还有演示文稿，以掌握一个科研人员基本的素质。&lt;/p&gt;
&lt;h2 id=&quot;学习资源&quot;&gt;&lt;a href=&quot;#学习资源&quot; class=&quot;headerlink&quot; title=&quot;学习资源&quot;&gt;&lt;/a&gt;学习资源&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.latexstudio.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$\LaTeX$开源小屋&lt;/a&gt;：很不错的中文$\LaTeX$社区，几乎应有尽有，资料很全&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cn.sharelatex.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ShareLaTeX&lt;/a&gt;：有丰富的模板，可以用来模仿&lt;/li&gt;
&lt;li&gt;GitHub，简书，CSDN等，上面都已一些相关的模板，文章等&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tex.stackexchange.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TeX StackExchange&lt;/a&gt;还有Stack Overflow：遇到问题可以去上面查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础结构&quot;&gt;&lt;a href=&quot;#基础结构&quot; class=&quot;headerlink&quot; title=&quot;基础结构&quot;&gt;&lt;/a&gt;基础结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;\documentclass&amp;#123;article&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;ctex&amp;#125;  %引入中文支持&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;document&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	\LaTeX&amp;#123;&amp;#125; 你好  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;document&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/23/latex-notes-01/图1-latex最基础模板.png&quot; alt=&quot;图1-latex最基础模板：\begin{environment\}...\end{environment} 中为内容，上面为导言区&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;bs-callout bs-callout-info&quot;&gt;&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;   用法&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt;   用法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\命令名称[备选参数]{（必选）参数}&lt;/code&gt;：叫做命令。个人感觉类似于HTML中的&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;。例如，&lt;code&gt;\documentclass[a4paper]{ctexart}&lt;/code&gt;，花括号中为必选参数，设置文档类型为&lt;code&gt;ctexart&lt;/code&gt;。中括号里备选参数&lt;code&gt;a4paper&lt;/code&gt;，将文档大小设置为A4纸大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\begin[...]{environment} ...\end{environment}&lt;/code&gt;：叫做环境，用于控制&lt;code&gt;\begin[...]{environment}&lt;/code&gt;和&lt;code&gt;\end{environment}&lt;/code&gt;之间的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Typesetting" scheme="https://www.blankspace.cn/categories/Typesetting/"/>
    
      <category term="TeX" scheme="https://www.blankspace.cn/categories/Typesetting/TeX/"/>
    
      <category term="LaTex" scheme="https://www.blankspace.cn/categories/Typesetting/TeX/LaTex/"/>
    
    
      <category term="TeX" scheme="https://www.blankspace.cn/tags/TeX/"/>
    
      <category term="LaTex" scheme="https://www.blankspace.cn/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>GitHub关键概念</title>
    <link href="https://www.blankspace.cn/2018/09/22/github-keywords/"/>
    <id>https://www.blankspace.cn/2018/09/22/github-keywords/</id>
    <published>2018-09-22T01:50:06.000Z</published>
    <updated>2018-09-22T06:49:43.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>是一个版本控制软件：</p><p>读作<code>[gɪt]</code>,拼音读作<code>gē yì te</code>。</p><blockquote><p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency. </p></blockquote><p><a href="https://github.com" target="_blank" rel="noopener">GitHub</a>是一个网站：</p><p>读作<code>[gɪt hʌb]</code>，拼音读作<code>gē yì te hà bo</code></p><blockquote><p>GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. </p></blockquote><p>通常自己一个人开发时使用Git有助于对代码版本进行控制，返回到之前任意时间点，能够合并多个分支流，解决或查看冲突。假如有协作开发作用更大。</p><p>而使用GitHub不仅能够用来存储Git库，其还会提供以下操作：</p><ul><li>文档需求：使用提出问题（issues），可以提出新的功能需求，记录缺陷，从而让团队进行开发</li><li>独立分支流记录：使用分支（branches）和拉请求（pull requests）,可以在不同的分支或功能下进行合作。</li><li>评估工作进展：通过查看拉请求（pull requests）列表，可以查看目前工作状态下的所有不同功能，通过单击列出的任何一个拉请求命令，可以看到最新变化以及所有关于该动的讨论。</li><li>看到团队的进展：通过使用Insights，可以看到团队的工作进展和脉冲（pulse）。</li></ul><h2 id="关键概念-术语"><a href="#关键概念-术语" class="headerlink" title="关键概念/术语"></a>关键概念/术语</h2><p>由于目前GitHub还是英文的，所以刚开始学习时不是很明白其中的某些概念，可能会觉得有点不明所以，经过一段时间的摸索，特整理如下：</p><h3 id="repository（仓库）"><a href="#repository（仓库）" class="headerlink" title="repository（仓库）"></a>repository（仓库）</h3><p>单数，a repository；复数，repositories。概念：</p><blockquote><p>a place, building, or receptacle where things are or may be stored. </p></blockquote><p>相当于一个项目（Project）文件夹，仓库名也就是项目文件夹名称，可以在里面存放代码，各种和项目有关的文档等。</p><p><img src="/2018/09/22/github-keywords/关键词示意.png" alt="1537585381087"></p><h3 id="watch（关注）"><a href="#watch（关注）" class="headerlink" title="watch（关注）"></a>watch（关注）</h3><p>长期关注某个项目的进展，设置在某些情况下发送提醒（到邮箱）。</p><h3 id="star（收藏）"><a href="#star（收藏）" class="headerlink" title="star（收藏）"></a>star（收藏）</h3><p>觉得某个项目不错，收藏一下，给个小星星，方便以后查看，同时也是对项目开发者的赞赏。</p><h3 id="fork（分叉）"><a href="#fork（分叉）" class="headerlink" title="fork（分叉）"></a>fork（分叉）</h3><p>有时候我没有直接改变某个项目的许可，或者我想参与一个你不知道的人或者团队的开源项目，就可以克隆，修改，并使用拉请求的方式将其提交到最初的项目中。</p><h3 id="issue（提出问题）"><a href="#issue（提出问题）" class="headerlink" title="issue（提出问题）"></a>issue（提出问题）</h3><p>用来讨论功能/需求，跟踪缺陷，或者两者兼备。比如我发现某个项目在PC上没问题，但移植到手机上就出现了位置的错误，就可以开一个issue来记录错误的过程。</p><h3 id="pull-request（拉请求）"><a href="#pull-request（拉请求）" class="headerlink" title="pull request（拉请求）"></a>pull request（拉请求）</h3><p>原先拉请求是用来请求别人复查自己已经完成的工作，并将它们合并到主分支上。现在，拉请求常用在一个流程的早期阶段，可以讨论可能的功能。</p><h3 id="clone（克隆）"><a href="#clone（克隆）" class="headerlink" title="clone（克隆）"></a>clone（克隆）</h3><p>将项目库复制到本地。例如我下载一个项目的副本，在本地将其中的某个bug修复，然后再提交回GitHub。</p><h3 id="wiki（维基文档记录）"><a href="#wiki（维基文档记录）" class="headerlink" title="wiki（维基文档记录）"></a>wiki（维基文档记录）</h3><p>当Readme比较长了，可以使用wiki进行文档记录，各个章节页面用简单的链接关系相联系。（通常我看好像没多少中国开发者选择使用wiki，有的readme相当长）。</p><h3 id="commit（提交）"><a href="#commit（提交）" class="headerlink" title="commit（提交）"></a>commit（提交）</h3><p>将一个或者多个文件的修改保存到Git历史记录中，都会创建一个新的提交。</p><h3 id="branch（分支）"><a href="#branch（分支）" class="headerlink" title="branch（分支）"></a>branch（分支）</h3><ul><li>主分支（master branch）</li><li>功能分支（feature branch）</li></ul><h3 id="merge（合并）"><a href="#merge（合并）" class="headerlink" title="merge（合并）"></a>merge（合并）</h3><p>将一个分支的全部工作合并到另一个分支，GitHub会在合并前检查是否有冲突并给出修改意见。</p><h3 id="release（发布）"><a href="#release（发布）" class="headerlink" title="release（发布）"></a>release（发布）</h3><p>到了一定阶段，项目已经差不多了，就可以新建release，版本x.xx，来发布正式版供别人打包下载。</p><h2 id="GitHub学习资源"><a href="#GitHub学习资源" class="headerlink" title="GitHub学习资源"></a>GitHub学习资源</h2><ul><li>初级：<a href="https://services.github.com/" target="_blank" rel="noopener">https://services.github.com/</a></li><li>高级：<a href="https://developer.github.com/" target="_blank" rel="noopener">https://developer.github.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-amp-GitHub&quot;&gt;&lt;a href=&quot;#Git-amp-GitHub&quot; class=&quot;headerlink&quot; title=&quot;Git &amp;amp; GitHub&quot;&gt;&lt;/a&gt;Git &amp;amp; GitHub&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="Version Control" scheme="https://www.blankspace.cn/categories/Version-Control/"/>
    
      <category term="Git" scheme="https://www.blankspace.cn/categories/Version-Control/Git/"/>
    
      <category term="GitHub" scheme="https://www.blankspace.cn/categories/Version-Control/Git/GitHub/"/>
    
    
      <category term="GitHub" scheme="https://www.blankspace.cn/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>（待完善...）使用Scikit-learn进行机器学习</title>
    <link href="https://www.blankspace.cn/2018/09/20/scikit-learn-ch01/"/>
    <id>https://www.blankspace.cn/2018/09/20/scikit-learn-ch01/</id>
    <published>2018-09-20T12:57:03.000Z</published>
    <updated>2018-10-05T04:29:16.481Z</updated>
    
    <content type="html"><![CDATA[<p>我发现使用scikit-learn上手简单，设计合理，接口统一，内置了很多机器学习算法，所以使用其来进行机器学习数据分析是一种极好的选择。根据一些经典的例子，复现和演示，来加深对于机器学习算法的理解。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h3><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="基于支持向量机（SVM）的图像分类"><a href="#基于支持向量机（SVM）的图像分类" class="headerlink" title="基于支持向量机（SVM）的图像分类"></a>基于支持向量机（SVM）的图像分类</h3><h3 id="基于朴素贝叶斯（Naive-Bayes）的文本分类"><a href="#基于朴素贝叶斯（Naive-Bayes）的文本分类" class="headerlink" title="基于朴素贝叶斯（Naïve Bayes）的文本分类"></a>基于朴素贝叶斯（Naïve Bayes）的文本分类</h3><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h3 id="房价预测"><a href="#房价预测" class="headerlink" title="房价预测"></a>房价预测</h3><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><h2 id="高级特征"><a href="#高级特征" class="headerlink" title="高级特征"></a>高级特征</h2><h3 id="Grid-Search"><a href="#Grid-Search" class="headerlink" title="Grid Search"></a>Grid Search</h3><p>…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我发现使用scikit-learn上手简单，设计合理，接口统一，内置了很多机器学习算法，所以使用其来进行机器学习数据分析是一种极好的选择。根据一些经典的例子，复现和演示，来加深对于机器学习算法的理解。&lt;/p&gt;
&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; cl
      
    
    </summary>
    
    
  </entry>
  
</feed>
