{"meta":{"title":"魔法师LQ的魔法书","subtitle":"研习魔法，改变世界.","description":"远不止魔法...","author":"liuqidev","url":"https://www.blankspace.cn"},"pages":[{"title":"","date":"2018-07-03T08:54:54.750Z","updated":"2018-07-03T08:54:54.620Z","comments":true,"path":"404.html","permalink":"https://www.blankspace.cn/404.html","excerpt":"","text":"404 Not Found 404 Not Found"},{"title":"tags","date":"2018-07-03T01:02:57.000Z","updated":"2018-07-03T01:04:00.709Z","comments":true,"path":"tags/index.html","permalink":"https://www.blankspace.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-03T01:04:15.000Z","updated":"2018-07-03T04:39:17.684Z","comments":true,"path":"categories/index.html","permalink":"https://www.blankspace.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"PATBL 数字分类","slug":"PATBL-数字分类","date":"2018-07-05T01:19:15.000Z","updated":"2018-07-05T05:26:41.321Z","comments":true,"path":"2018/07/05/PATBL-数字分类/","link":"","permalink":"https://www.blankspace.cn/2018/07/05/PATBL-数字分类/","excerpt":"","text":"时间限制 1000 ms 内存限制 32768 KB 代码长度限制 100 KB 判断程序 Standard (来自 小小) 题目描述给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字： A1 = 能被5整除的数字中所有偶数的和； A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…； A3 = 被5除后余2的数字的个数； A4 = 被5除后余3的数字的平均数，精确到小数点后1位； A5 = 被5除后余4的数字中最大数字。 输入描述:每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出描述:对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出“N”。 输入例子: 13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出例子: 30 11 2 9.7 9 方法1：函数创建一个函数，直接处理上述情况，返回一个vector，保留计算结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;// 能被5整除的数字中所有偶数的和ll f1(vector&lt;int&gt; e, int n) &#123; ll sum = 0; for (vector&lt;int&gt;::iterator it = e.begin(); it != e.end(); it++) &#123; sum += ((*it % 5 == 0) &amp;&amp; (*it % 2 == 0)) ? *it : 0; &#125; return sum;&#125;// 将被5除后余1的数字按给出顺序进行交错求和ll f2(vector&lt;int&gt; e, int n) &#123; ll sum = 0; int cnt = 0; for (vector&lt;int&gt;::iterator it = e.begin(); it != e.end(); it++) &#123; if (*it % 5 == 1) &#123; sum += pow(-1, cnt)*(*it); cnt++; &#125; &#125; return sum;&#125;// 整合到一个函数中vector&lt;double&gt; f(vector&lt;int&gt; e, int n)&#123; vector&lt;double&gt; ans; double sum1 = 0, sum2=0, sum4=0; int cnt2 = 0, cnt3=0, cnt4=0; int mx = -1; for (vector&lt;int&gt;::iterator it = e.begin(); it != e.end(); it++) &#123; sum1 += ((*it % 5 == 0) &amp;&amp; (*it % 2 == 0)) ? *it : 0; if (*it % 5 == 1) &#123; sum2 += pow(-1, cnt2)*(*it); cnt2++; &#125; if (*it % 5 == 2) &#123; cnt3++; &#125; if (*it % 5 == 3) &#123; cnt4++; sum4+=(*it); &#125; if (*it % 5 == 4) &#123; if (mx &lt; *it) &#123; mx = *it; &#125; &#125; &#125; ans.push_back(sum1); ans.push_back(sum2); ans.push_back(cnt3); ans.push_back(sum4/(double)cnt4); ans.push_back(mx); return ans;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); int n; scanf(\"%d\", &amp;n); vector&lt;int&gt; e; for (int i = 1; i &lt;= n; ++i) &#123; int a; scanf(\"%d\", &amp;a); e.push_back(a); &#125; //printf(\"%lld\\n\", f1(e, n)); //printf(\"%lld\\n\", f2(e, n)); vector&lt;double&gt; ans = f(e, n); for (vector&lt;double&gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123; //printf(\"%d\\n\", it - ans.begin()); int i = it - ans.begin(); if (i == 3) &#123; printf(\"%.1f \", (*it)); &#125; else if (i == 4) &#123; printf(\"%d\\n\", (int)*it); &#125; else &#123; printf(\"%d \", (int)*it); &#125; &#125; return 0;&#125; 结果 直接求解对不存在的情况，以及输出格式进行处理。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); int n; scanf(\"%d\", &amp;n); vector&lt;int&gt; e; for (int i = 1; i &lt;= n; ++i) &#123; int a; scanf(\"%d\", &amp;a); e.push_back(a); &#125; ll sum1 = 0, sum2 = 0, sum4 = 0; //int cnt1=0, cnt2 = 0, cnt3 = 0, cnt4 = 0, cnt5=0; int cnt[6] = &#123; 0 &#125;; int mx = -1; for (vector&lt;int&gt;::iterator it = e.begin(); it != e.end(); it++) &#123; if (*it % 5 == 0&amp;&amp; (*it % 2 == 0)) &#123; sum1 += *it; cnt[1]++; &#125; if (*it % 5 == 1) &#123; sum2 += pow(-1, cnt[2])*(*it); cnt[2]++; &#125; if (*it % 5 == 2) &#123; cnt[3]++; &#125; if (*it % 5 == 3) &#123; cnt[4]++; sum4 += (*it); &#125; if (*it % 5 == 4) &#123; cnt[5]++; if (mx &lt; *it) &#123; mx = *it; &#125; &#125; &#125; for (int i = 1; i &lt;= 5; ++i) &#123; if (cnt[i] == 0) &#123; if (i == 5) &#123; printf(\"%c\", 'N'); &#125; else &#123; printf(\"%c \", 'N'); &#125; &#125; else &#123; if (i == 4) &#123; printf(\"%.1f \", sum4 / (double)cnt[i]); &#125; else if (i==5)&#123; printf(\"%d\", mx); &#125; else if (i==3)&#123; printf(\"%d \", cnt[3]); &#125; else if (i == 2) &#123; printf(\"%lld \", sum2); &#125; else if (i == 1) &#123; printf(\"%lld \", sum1); &#125; &#125; &#125; return 0;&#125; 结果","categories":[{"name":"PAT认证","slug":"PAT认证","permalink":"https://www.blankspace.cn/categories/PAT认证/"}],"tags":[{"name":"PAT认证（乙级）","slug":"PAT认证（乙级）","permalink":"https://www.blankspace.cn/tags/PAT认证（乙级）/"},{"name":"数组","slug":"数组","permalink":"https://www.blankspace.cn/tags/数组/"}]},{"title":"PATBL A加B和C","slug":"PATBL-A加B和C","date":"2018-07-05T00:22:48.000Z","updated":"2018-07-05T01:21:46.826Z","comments":true,"path":"2018/07/05/PATBL-A加B和C/","link":"","permalink":"https://www.blankspace.cn/2018/07/05/PATBL-A加B和C/","excerpt":"","text":"时间限制 1000 ms 内存限制 32768 KB 代码长度限制 100 KB 判断程序 Standard (来自 小小) 题目描述给定区间[-2的31次方, 2的31次方]内的3个整数A、B和C，请判断A+B是否大于C。 输入描述:输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出描述:对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。 输入例子: 41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出例子: Case #1: falseCase #2: trueCase #3: trueCase #4: false 分析注意到A，B，C的范围，A+B可能会超过int的范围，所以使用long long来存储，防止溢出。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= T; ++i) &#123; ll a, b, c; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;c); printf(\"Case #%d: %s\\n\", i, (a+b)&gt;c?\"true\":\"false\"); &#125; return 0;&#125; 结果","categories":[{"name":"PAT认证","slug":"PAT认证","permalink":"https://www.blankspace.cn/categories/PAT认证/"}],"tags":[{"name":"PAT认证（乙级）","slug":"PAT认证（乙级）","permalink":"https://www.blankspace.cn/tags/PAT认证（乙级）/"},{"name":"a+b problem","slug":"a-b-problem","permalink":"https://www.blankspace.cn/tags/a-b-problem/"}]},{"title":"栈","slug":"stack","date":"2018-07-04T13:42:00.000Z","updated":"2018-07-05T01:14:14.420Z","comments":true,"path":"2018/07/04/stack/","link":"","permalink":"https://www.blankspace.cn/2018/07/04/stack/","excerpt":"","text":"描述实现一个栈，完成以下功能： 入栈 出栈 询问栈中位置Y是谁 一开始栈为空。栈中的位置从1开始（即栈底位置为1）。 输入第一行一个整数n，表示操作个数。 接下来n行，每行第一个数字表示操作（见描述）： 若为数字1，则接下来有一串字符串X，表示将X压入栈中。 若为数字2，表示弹出栈顶（保证栈非空），并输出出栈的这个人。 若为数字3，则接下来有一个整数Y，表示询问栈中位置Y是谁（保证位置Y合法），并输出名字。 输出将所有操作2和操作3输出，一行一个。 输入样例 111 a1 b1 c3 13 23 321 d3 13 23 3 输出样例 abccabd 限制对于30%的数据，1 ≤ n ≤ 2000； 对于另30%的数据，没有操作3； 对于100%的数据，1 ≤ n ≤ 100000。 数据中出现的字符串只包含26个小写字母（无空格等分隔符），且长度不超过15。 字符串有可能重复。正如现实中可能有重名一样。 时间：2 sec 空间：256 MB 方法1 数组模拟入栈和出栈都是操作着栈顶。 开一个大小为n的数组，记录栈顶的位置，入栈出栈就是将这栈顶加一减一，栈中某个位置Y在数组相应的下标就是Y。时间复杂度：O(1)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */const int N = 100005;// Stack: 栈// top: 栈顶位置string Stack[N];int n, top;// 压入栈顶// name：被压入的人的姓名void push(string name) &#123; Stack[++top] = name;&#125;// 弹出栈顶// 返回值：被弹出人的姓名string pop() &#123; return Stack[top--];&#125;// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）// pos：询问的位置// 返回值：pos位置上人的姓名string query(int pos) &#123; return Stack[pos];&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf(\"%d\", &amp;n); char name[20]; for (; n--; ) &#123; int op; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%s\", name); push(name); &#125; else if (op == 2) &#123; printf(\"%s\\n\", pop().c_str()); &#125; else &#123; int pos; scanf(\"%d\", &amp;pos); printf(\"%s\\n\", query(pos).c_str()); &#125; &#125; return 0;&#125; 结果 方法2 动态方法使用指针和new来动态开辟内存空间。push和pop和方法1类似，query则也遵守LIFO。时间复杂度：O(n)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;class MyStack &#123;private: int _top; // 栈顶位置 int _size; // 栈大小 int _capacity; //最大容量 string *elements; // 数据的存储区 void _overflow(); // 防止溢出，扩容public: MyStack(int n); // 构造函数 ~MyStack() &#123; delete[] elements; &#125; //析构函数 // 实现的接口 void push(string s); string pop(); string query(int pos); bool is_empty(); bool is_full(); int size(); string top();&#125;;int main()&#123; int N = 1005; MyStack st = MyStack(N); int num_ops; cin &gt;&gt; num_ops; for (int i = 0; i &lt; num_ops; ++i) &#123; int op = 0; string s=\"\"; cin &gt;&gt; op; if (op == 1) &#123; //入栈 cin &gt;&gt; s; st.push(s); &#125; else if (op == 2) &#123; //出栈 string r = st.pop(); cout &lt;&lt; r &lt;&lt; endl; &#125; else if (op == 3) &#123; //查询 int pos; cin &gt;&gt; pos; cout&lt;&lt;st.query(pos)&lt;&lt;endl; &#125; &#125; return 0;&#125;void MyStack::_overflow()&#123; string* new_elements = new string[_capacity * 2];//扩容成原来的两倍 // 将原来的数据放到新的存储区来 for (int i = 0; i &lt;= _top; ++i) &#123; new_elements[i] = elements[i]; &#125; _capacity = _capacity * 2; delete[] elements; //释放掉原来的存储空间 elements = new_elements;&#125;MyStack::MyStack(int n)&#123; elements = new string[n]; _top = 0;// 栈顶从1开始,若从0开始则初始化为-1 _size = 0; assert(elements != NULL); elements[_top] = '#'; //特殊字符作为哨兵 //cout &lt;&lt; \"初始化成功!\" &lt;&lt; endl; //cout &lt;&lt; \"栈大小为:\" &lt;&lt; size() &lt;&lt; endl;&#125;// 弹出栈顶// 返回值：被弹出人的姓名string MyStack::pop()&#123; assert(_size &gt; 0); //cout &lt;&lt; \"弹出栈顶元素:\" &lt;&lt; top() &lt;&lt; endl; _size--; //cout &lt;&lt; \"弹出后栈大小为:\" &lt;&lt; size() &lt;&lt; endl; return elements[_top--];&#125;// 压入栈顶// s：被压入的人的姓名void MyStack::push(string s)&#123; if (is_full()) &#123; _overflow(); &#125; elements[++_top] = s; _size++; //cout &lt;&lt; \"当前栈顶元素:\" &lt;&lt; top() &lt;&lt; endl; //cout &lt;&lt; \"栈大小为:\" &lt;&lt; size() &lt;&lt; endl;&#125;bool MyStack::is_empty()&#123; return _size==0;&#125;bool MyStack::is_full()&#123; return (_top == _capacity - 1) ? true : false;&#125;int MyStack::size()&#123; return _size;&#125;string MyStack::top()&#123; return elements[_top];&#125;// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）// pos：询问的位置// 返回值：pos位置上人的姓名string MyStack::query(int pos)&#123; string rst; MyStack tmp(size()); //将要查询位置之前的元素统统弹出 while (pos &lt; _top) &#123; tmp.push(pop()); &#125; //查询到后将弹出的元素再弹回 rst = pop(); push(rst); //查询并不改变原有的数据结构 while(!tmp.is_empty()) &#123; push(tmp.pop()); &#125; return rst;&#125; 结果 方法2比方法1慢得多，原因主要在于动态分配存储和查询。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.blankspace.cn/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.blankspace.cn/tags/栈/"},{"name":"解题报告","slug":"解题报告","permalink":"https://www.blankspace.cn/tags/解题报告/"}]},{"title":"坐而论道：邓公谈清华数据结构的新百年","slug":"邓公谈清华数据结构新百年","date":"2018-07-04T08:41:04.000Z","updated":"2018-07-04T13:00:27.063Z","comments":true,"path":"2018/07/04/邓公谈清华数据结构新百年/","link":"","permalink":"https://www.blankspace.cn/2018/07/04/邓公谈清华数据结构新百年/","excerpt":"","text":"本文是邓俊辉老师某次直播中关于数据结构课程问答的简记和摘要。 中、小学生问：拿到了慕课的（优秀）证书，接下来如何朝着清华的计算机系方向努力？ “ CS之路漫长。知识分阶段，分层次，暂时不用想太远。兴趣，持续？数理基础？离散，代数；细致的科学，规范统一，问题大规模。” 为什么C++？ “最初Java，美国流行。国内C到C++，调整，逐渐适应。算法和数据结构不应依赖于具体语言。课程中只用到C++的子集。” 学习算法和数据结构需要什么基础？ “没有绕不过的坎。 如开车， Level 0-驾校：怎么用，宏观的； Level 1-发烧友：没有万能的数据结构，目前的数据结构都是有针对性的，针对于某一类特定的问题或者说适用于某一类特定的对象。能识优劣，学会选择； Level 2: 设计算法。算法已经发展到比较成熟的阶段。 各取所需。通用的学科。” 课程和讲义并非完全对应？ “面向不同基础，层次的人。 统一教材，统一讲义，标记，编号作为区分和弥补。” 如何设置MOOC，混合式课堂的问题？ “问题来自学生，有反馈的渠道。相对集中的时间，集中收集问题，分类。要实际，基础性，理论的问题，学生自己掌握的（比传统课堂）比较好。灵活的，实际的问题稍欠缺。” 计算机和数学之关系？ “公认的，依存度很高，例如，《The Art of Computer Programming》，重要的是其中的习题；清华CS很多和数学系同学一同上课；坚持下来。 数学能告诉我们什么不能做。 技术不能解决所有问题，有的要诉诸于哲学，艺术和文化，并行不悖。 表面悲观，更敏锐了，辨是非，把精力放在更高效的地方。” 划重点? “没有明显的重点，环环相扣，紧密相连。例如红黑树，前一环就是AVL树。把基础的，前辈的知识先学好。” 经典的书如《算法导论》，适合什么人看？ “前面谈的发烧友级别，《算导》，《计算机编程艺术》，《算法》等这些经典的书都要看，老师从这里学到的。实证。可视化。” 慕课开课讲师的感受？ ”接触很早，最早怀疑态度。’上春晚‘，有个人抱负在其中。身份特殊，使命，接力棒传接。 事实和数字。事实：国内至少当时讲数据结构的教材，内容和体例，和自己当年读书时大部分一样；数字：工作30年，学科的内容没有提上去。虽然把教材写出来，但影响有限。内容为王。 制作成本很低。个人潜能爆发期。尽可能保持完整性。将校内的平台打通，THU校内公选课课堂，甚至CST计算机系课堂。讲义，程序，演示，免费下载。教学工具，记下所有的笔记。有纵深，内容完整，能够玩起来，共享 。 “ 会开后续的MOOC吗？ “不大可能，但学无止境。知识体系，基本贯通了（1000多个知识点）。ACM &amp; IEEE Computer Science Curricula，是主要参考，但怎么做都不可能完全覆盖，怎么做都不够。 大数据，有所体现，小集合，重复，例如一个测点数据量几百兆，强调问题的真实性。 正在写第四版教材。” 如何检索到课程中没有出现的数据结构？ “查查handbook。 汪洋大海，学习其子集。抓住骨架和方法。 不要在意自己什么没学，思考算法和数据结构背后的（原理和思想），为什么能成，最终建立自信！” 数据结构新领域，新模式 “例如GPU，流计算，online的计算。懂一些硬件。暂未脱离图灵，冯诺依曼体系，数据为中心，存储程序，”凡物皆数”，有的数据一去不复还。学习方法，不变的东西。 “ 继续深造，学习慕课就够了吗？有什么书单？ “完全有可能。 要学通学透，要灵活，会应用。 “好学生”，四个方面， 1.思维方式，计算思维，学会使用这种计算思维解决问题，严谨，求异思维，在前人的基础上，学习行业的思维方式； 2.样式套路：知识点，解题方法，数据结构和算法，硬币正反面;方法论，如分而治之，减而治之等； 3.综合应用能力； 4.针对一些问题，在没有现成解决方案的情况下，自己造轮子，改轮子，给别人用。” 对考研有什么帮助？ 考的就是THU，dsa分数占比最大，自主命题。打住。肯定是有帮助。 什么才是“一流的课程”? “什么是好老师？个性，风范。学术的基因，多年之后能够记起。 好课程？要严肃，有考试，作业，DDL，分数不能很高。 苦涩的感觉。痛并快乐着。回甘，有趣，味。在不同阶段有不同味道。 ” 清华的情怀是什么？ “教给我，真诚。’不自欺，不想欺‘。 认为自己教的东西是美的。 有担当。 如何当一个读书人：士之读书治学，盖将以脱心志于俗谛之桎梏，真理因得以发扬。不要受到桎梏，读书是摆脱精神桎梏最简便的途径。 “","categories":[{"name":"演讲","slug":"演讲","permalink":"https://www.blankspace.cn/categories/演讲/"}],"tags":[{"name":"清华","slug":"清华","permalink":"https://www.blankspace.cn/tags/清华/"},{"name":"邓俊辉","slug":"邓俊辉","permalink":"https://www.blankspace.cn/tags/邓俊辉/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.blankspace.cn/tags/数据结构/"},{"name":"mooc","slug":"mooc","permalink":"https://www.blankspace.cn/tags/mooc/"}]},{"title":"本博客基本操作备忘","slug":"备忘","date":"2018-07-03T08:27:26.000Z","updated":"2018-07-03T14:54:46.251Z","comments":true,"path":"2018/07/03/备忘/","link":"","permalink":"https://www.blankspace.cn/2018/07/03/备忘/","excerpt":"文章归类和标记比较完整的文章设置：12345678910---layout: page/tags/categoriestitle: xxx # 必须，页面名称date: 2018-07-03 16:27:26tags: [Hexo, HTML]categories: [Web前端]description: 描述 # 页面二级标题，描述性文字comments: false/truereward: false/true # 打赏--- 生成摘要在 Markdown 中加 &lt;!-- more --&gt;","text":"文章归类和标记比较完整的文章设置：12345678910---layout: page/tags/categoriestitle: xxx # 必须，页面名称date: 2018-07-03 16:27:26tags: [Hexo, HTML]categories: [Web前端]description: 描述 # 页面二级标题，描述性文字comments: false/truereward: false/true # 打赏--- 生成摘要在 Markdown 中加 &lt;!-- more --&gt; 文章中插入文字 引用1&gt; 幼小，可怜，又无助。 幼小，可怜，又无助。 代码 123# i want to flyfrom fly import fly i.fly() 公式 123$$C^&#123;m&#125;_&#123;n&#125;=\\frac&#123;n!&#125;&#123;m!\\left( n-m\\right)!&#125;$$ $$C^{m}_{n}=\\frac{n!}{m!\\left( n-m\\right)!}$$ 图标先到fontawesome查找需要的图标，然后在文章中按照如下规则输入： 1&lt;i class=\"icon icon-book\"&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=\"icon icon-book icon-lg\"&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=\"icon icon-book icon-2x\"&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=\"icon icon-book icon-3x\"&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=\"icon icon-book icon-4x\"&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=\"icon icon-book icon-5x\"&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=\"icon icon-book icon-pr\"&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=\"icon icon-book icon-pl\"&gt;&lt;/i&gt; 图片 视频1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=25772366&amp;cid=44004290&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt; &lt;/iframe&gt; 音乐：123&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=2117009&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt;&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"100%\" height=\"650\" src=\"http://music.163.com/outchain/player?type=0&amp;id=75791641&amp;auto=0&amp;height=430\"&gt;&lt;/iframe&gt; PDF1&lt;embed src=\"matrixcookbook.pdf#toolbar=0&amp;navpanes=0&amp;scrollbar=0\" width=\"100%\" height=\"600px\"&gt; 1&lt;iframe src=\"matrixcookbook.pdf\" width=\"100%\" height=\"600px\"&gt;&lt;/iframe&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://www.blankspace.cn/categories/Web前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.blankspace.cn/tags/Hexo/"},{"name":"HTML","slug":"HTML","permalink":"https://www.blankspace.cn/tags/HTML/"}]}]}